{
  "id": "aEzuOXgpLBTNZ4ie",
  "name": "BAT AI Task Dispatcher",
  "active": false,
  "nodes": [
    {
      "parameters": {},
      "id": "a13e9b6c-3695-463a-83f3-42859af26799",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -1056,
        -352
      ]
    },
    {
      "parameters": {
        "jsCode": "// Normalize Input - извлекаем appeal_id и tenant_id из разных форматов\nconst input = $input.first().json;\n\nconsole.log('=== NORMALIZE INPUT ===');\nconsole.log('Input keys:', Object.keys(input));\n\n// Ищем appeal_id в разных местах\nconst appeal_id = input.appeal_id \n  || input.appeal?.id \n  || input.id;\n\n// Ищем tenant_id\nconst tenant_id = input.tenant_id \n  || input.appeal?.tenant_id;\n\n// Ищем client_id\nconst client_id = input.client_id\n  || input.appeal?.client_id;\n\n// Текст сообщения\nconst text = input.text \n  || input.message \n  || input.chatInput \n  || '';\n\nconsole.log('Normalized appeal_id:', appeal_id);\nconsole.log('Normalized tenant_id:', tenant_id);\nconsole.log('Normalized client_id:', client_id);\nconsole.log('Text:', text.substring(0, 50));\n\nif (!appeal_id) {\n  throw new Error('appeal_id not found in input! Keys: ' + Object.keys(input).join(', '));\n}\n\nif (!tenant_id) {\n  throw new Error('tenant_id not found in input!');\n}\n\nreturn {\n  ...input,\n  appeal_id: appeal_id,\n  tenant_id: tenant_id,\n  client_id: client_id,\n  text: text\n};"
      },
      "id": "76cbd68a-04ca-4f04-b963-a01f7cbe2d62",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -832,
        -352
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT json_build_object(\n  'appeal', row_to_json(a.*),\n  'client_id', a.client_id,\n  'devices', COALESCE(\n    (SELECT json_agg(json_build_object(\n      'id', ad.id,\n      'device_index', ad.device_index,\n      'brand_id', ad.brand_id,\n      'brand_name', b.name,\n      'model_id', ad.model_id,\n      'model_name', mdl.name,\n      'repairs', (SELECT json_agg(json_build_object(\n        'id', ar.id,\n        'category_id', ar.repair_category_id,\n        'category_name', rc.name\n      )) FROM appeal_repairs ar LEFT JOIN repair_categories rc ON rc.id = ar.repair_category_id WHERE ar.appeal_device_id = ad.id)\n    ) ORDER BY ad.device_index)\n    FROM appeal_devices ad\n    LEFT JOIN brands b ON b.id = ad.brand_id\n    LEFT JOIN models mdl ON mdl.id = ad.model_id\n    WHERE ad.appeal_id = a.id),\n    '[]'::json\n  ),\n  'entity_configs', COALESCE(\n    (SELECT json_agg(row_to_json(ec.*) ORDER BY ec.priority)\n     FROM ai_entity_configs ec\n     WHERE ec.tenant_id = a.tenant_id\n       AND ec.vertical_id = 'repair'\n       AND ec.is_active = true),\n    '[]'::json\n  ),\n  'recent_messages', COALESCE(\n    (SELECT json_agg(json_build_object(\n      'text', msg.text,\n      'sender_type', msg.sender_type,\n      'created_at', msg.created_at\n    ) ORDER BY msg.created_at DESC)\n     FROM messages msg\n     WHERE msg.appeal_id = a.id\n     LIMIT 10),\n    '[]'::json\n  )\n) as data\nFROM appeals a\nWHERE a.id = '{{ $json.appeal_id }}'::uuid;",
        "options": {}
      },
      "id": "c47b022e-4eed-443d-8245-1fefa45a94df",
      "name": "Load Appeal Data",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -608,
        -352
      ],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://n8n.n8nsrv.ru/webhook/neo4j/context",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"client_id\": \"{{ $('Load Appeal Data').first().json.data.client_id }}\",\n  \"action\": \"get_context\"\n}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "neo4j-context-001",
      "name": "Get Neo4j Context",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -384,
        -512
      ],
      "onError": "continueRegularOutput",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Получаем нормализованные данные\nlet input = null;\ntry {\n  input = $('Normalize Input').first().json;\n} catch (e) {\n  input = $('Execute Workflow Trigger').first()?.json || {};\n}\n\nconst dbResult = $('Load Appeal Data').first().json;\nconst data = typeof dbResult.data === 'string' ? JSON.parse(dbResult.data) : dbResult.data;\n\n// Получаем контекст из Neo4j (может быть пустым если Neo4j недоступен)\nlet neo4jContext = {};\ntry {\n  neo4jContext = $('Get Neo4j Context').first()?.json || {};\n} catch (e) {\n  console.log('Neo4j context not available:', e.message);\n}\n\nconst devices = data?.devices || [];\nconst entityConfigs = data?.entity_configs || [];\nconst recentMessages = data?.recent_messages || [];\nconst message = input.text || input.message || '';\n\n// === ФОРМИРУЕМ КОНТЕКСТ ДЛЯ AI ===\n\n// 1. История сообщений (из PostgreSQL)\nconst messageHistory = recentMessages\n  .slice(0, 5)\n  .reverse()\n  .map(m => `${m.sender_type === 'client' ? 'Клиент' : 'Оператор'}: ${m.text}`)\n  .join('\\n') || 'Новый диалог';\n\n// 2. Текущие устройства (комбинируем PostgreSQL + Neo4j)\nlet currentDevices = '';\n\n// Сначала пробуем Neo4j (более полный контекст)\nif (neo4jContext.devices && neo4jContext.devices.length > 0) {\n  currentDevices = neo4jContext.devices\n    .map(d => {\n      let desc = `${d.brand || ''} ${d.model || ''}`.trim();\n      if (d.owner_label) desc += ` (${d.owner_label})`;\n      return desc;\n    })\n    .filter(d => d)\n    .join(', ');\n}\n\n// Fallback на PostgreSQL данные\nif (!currentDevices && devices.length > 0) {\n  currentDevices = devices\n    .map(d => {\n      let desc = `${d.brand_name || ''} ${d.model_name || ''}`.trim();\n      const repairs = d.repairs?.map(r => r.category_name).filter(Boolean).join(', ');\n      if (repairs) desc += ` [${repairs}]`;\n      return desc;\n    })\n    .filter(d => d)\n    .join(', ');\n}\n\nif (!currentDevices) {\n  currentDevices = 'Устройство не указано';\n}\n\n// 3. Активные проблемы из Neo4j\nlet activeProblems = '';\nif (neo4jContext.problems && neo4jContext.problems.length > 0) {\n  activeProblems = neo4jContext.problems\n    .filter(p => p.status === 'in_progress')\n    .map(p => p.type)\n    .join(', ');\n}\n\nconsole.log('=== PREPARE TASKS ===');\nconsole.log('Appeal ID:', input.appeal_id);\nconsole.log('Entity configs:', entityConfigs.length);\nconsole.log('Devices from DB:', devices.length);\nconsole.log('Neo4j context available:', !!neo4jContext.success);\nconsole.log('Message history length:', messageHistory.length);\nconsole.log('Current devices:', currentDevices);\n\nconst activeDevice = devices.length > 0 ? devices[devices.length - 1] : null;\nconst hasExtractedData = activeDevice && (activeDevice.brand_id || activeDevice.model_id);\n\nconst batchId = `batch-${input.appeal_id}-${Date.now()}`;\n\n// Берём ВСЕ активные entity_types за один проход\nconst entitiesToExtract = entityConfigs\n  .filter(c => c.is_active !== false)\n  .map(c => c.entity_type);\n\nconst tasks = entityConfigs\n  .filter(c => entitiesToExtract.includes(c.entity_type))\n  .map((config, idx) => {\n    // === ПОДСТАНОВКА ПЕРЕМЕННЫХ В ПРОМПТ ===\n    let prompt = config.user_prompt_template || '';\n    \n    // Заменяем плейсхолдеры\n    prompt = prompt\n      .replace(/\\{message_history\\}/g, messageHistory)\n      .replace(/\\{current_devices\\}/g, currentDevices)\n      .replace(/\\{active_problems\\}/g, activeProblems || 'Нет активных проблем')\n      .replace(/\\{client_message\\}/g, message);\n    \n    return {\n      json: {\n        id: `task-${Date.now()}-${idx}`,\n        batch_id: batchId,\n        tenant_id: input.tenant_id,\n        appeal_id: input.appeal_id,\n        entity_config_id: config.id,\n        entity_type: config.entity_type,\n        device_index: devices.length > 0 ? devices.length - 1 : 0,\n        priority: config.priority,\n        input_message: message,\n        prompt: prompt,\n        system_prompt: config.system_prompt,\n        _meta: {\n          batch_id: batchId,\n          total_tasks: entitiesToExtract.length,\n          has_extracted_data: hasExtractedData,\n          active_device: activeDevice,\n          neo4j_available: !!neo4jContext.success,\n          context: {\n            message_history: messageHistory,\n            current_devices: currentDevices,\n            active_problems: activeProblems\n          }\n        }\n      }\n    };\n  });\n\nif (tasks.length === 0) {\n  console.log('No tasks to process');\n  return {\n    json: {\n      no_tasks: true,\n      appeal_id: input.appeal_id,\n      tenant_id: input.tenant_id,\n      has_extracted_data: hasExtractedData,\n      active_device: activeDevice\n    }\n  };\n}\n\nconsole.log('Created tasks:', tasks.length);\nreturn tasks;"
      },
      "id": "de08041a-e554-4f05-9ce9-bbff18da18ec",
      "name": "Prepare Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -352
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "typeValidation": "loose"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "has-tasks",
              "operator": {
                "type": "boolean",
                "operation": "false"
              },
              "leftValue": "={{ $json.no_tasks }}",
              "rightValue": ""
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "id": "085eee56-849d-4ab8-a97f-b70673483046",
      "name": "Has Tasks?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        64,
        -352
      ]
    },
    {
      "parameters": {
        "operation": "push",
        "list": "ai_extraction_queue",
        "messageData": "={{ JSON.stringify($json) }}",
        "tail": true
      },
      "id": "657905dc-f01a-4b5d-a1dd-f56062109223",
      "name": "Push to Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        272,
        -448
      ],
      "credentials": {
        "redis": {
          "id": "7FQcEivUY94atW24",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=batch:{{ $json._meta.batch_id }}:status",
        "value": "={{ JSON.stringify({ total: $json._meta.total_tasks, completed: 0, results: [] }) }}",
        "expire": true,
        "ttl": 300
      },
      "id": "94f9cba8-1e14-4ed2-b3ec-96ab6ef0a708",
      "name": "Set Batch Status",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        496,
        -448
      ],
      "credentials": {
        "redis": {
          "id": "7FQcEivUY94atW24",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const firstItem = $('Prepare Tasks').first().json;\nconst meta = firstItem._meta;\n\nconst maxWaitMs = 30000;\nconst pollIntervalMs = 200;\nconst startTime = Date.now();\n\nreturn {\n  batch_id: meta.batch_id,\n  appeal_id: firstItem.appeal_id,\n  tenant_id: firstItem.tenant_id,\n  total_tasks: meta.total_tasks,\n  max_wait_ms: maxWaitMs,\n  poll_interval_ms: pollIntervalMs,\n  start_time: startTime,\n  poll_count: 0\n};"
      },
      "id": "295773c5-a868-4b96-b686-6fa71c0a968a",
      "name": "Init Wait Loop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        -448
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  COUNT(*) FILTER (WHERE status = 'completed') as completed,\n  COUNT(*) FILTER (WHERE status = 'failed') as failed,\n  COUNT(*) as total,\n  json_agg(json_build_object(\n    'entity_type', entity_type,\n    'status', status,\n    'parsed_result', parsed_result\n  )) FILTER (WHERE status IN ('completed', 'failed')) as results\nFROM ai_extraction_tasks\nWHERE appeal_id = '{{ $json.appeal_id }}'::uuid\n  AND created_at > NOW() - INTERVAL '5 minutes';",
        "options": {}
      },
      "id": "b1cf3036-1d0a-4fa0-857b-ff7930f776c5",
      "name": "Poll DB Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        944,
        -448
      ],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const waitData = $('Init Wait Loop').item.json;\nconst pollResult = $input.item.json;\n\nconst completed = parseInt(pollResult.completed) || 0;\nconst failed = parseInt(pollResult.failed) || 0;\nconst total = waitData.total_tasks;\nconst done = completed + failed;\n\nconst elapsed = Date.now() - waitData.start_time;\nconst isTimeout = elapsed >= waitData.max_wait_ms;\nconst isComplete = done >= total;\n\nreturn {\n  ...waitData,\n  poll_count: waitData.poll_count + 1,\n  completed: completed,\n  failed: failed,\n  done: done,\n  is_complete: isComplete,\n  is_timeout: isTimeout,\n  should_continue: !isComplete && !isTimeout,\n  results: pollResult.results || [],\n  elapsed_ms: elapsed\n};"
      },
      "id": "06edddce-cf81-4c97-bce8-f1ebf4d8e235",
      "name": "Check Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1152,
        -448
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "should-continue",
              "operator": {
                "type": "boolean",
                "operation": "true"
              },
              "leftValue": "={{ $json.should_continue }}",
              "rightValue": ""
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "id": "438775a1-6c31-4a6f-bc8a-2d3fde0b9d91",
      "name": "Continue Polling?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1376,
        -448
      ]
    },
    {
      "parameters": {
        "amount": 0.3
      },
      "id": "85e16091-e49a-4095-a9db-b102fff10e26",
      "name": "Wait 300ms",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1568,
        -704
      ],
      "webhookId": "057ec02c-04fa-4a52-9624-64c00bd9fbb4"
    },
    {
      "parameters": {
        "jsCode": "const checkResult = $('Check Completion').item.json;\nconst results = checkResult.results || [];\n\nconst extracted = {\n  appeal_type: null,\n  brand: null,\n  brand_id: null,\n  model: null,\n  model_id: null,\n  repair_category: null,\n  repair_category_id: null,\n  repair_action: null,\n  parts_owner: null\n};\n\nfor (const result of results) {\n  if (result.status !== 'completed') continue;\n  const parsed = result.parsed_result || {};\n  \n  switch (result.entity_type) {\n    case 'appeal_type':\n      extracted.appeal_type = parsed.appeal_type || parsed.type;\n      break;\n    case 'brand':\n      extracted.brand = parsed.brand || parsed.name;\n      extracted.brand_id = parsed.brand_id || parsed.id;\n      break;\n    case 'model':\n      extracted.model = parsed.model || parsed.name;\n      extracted.model_id = parsed.model_id || parsed.id;\n      break;\n    case 'repair_category':\n      extracted.repair_category = parsed.repair_category || parsed.category || parsed.name;\n      extracted.repair_category_id = parsed.repair_category_id || parsed.category_id || parsed.id;\n      break;\n    case 'repair_action':\n      extracted.repair_action = parsed.repair_action || parsed.action;\n      break;\n    case 'parts_owner':\n      extracted.parts_owner = parsed.parts_owner || 'workshop';\n      break;\n  }\n}\n\nreturn {\n  action: 'extraction_complete',\n  appeal_id: checkResult.appeal_id,\n  tenant_id: checkResult.tenant_id,\n  batch_id: checkResult.batch_id,\n  total_tasks: checkResult.total_tasks,\n  completed: checkResult.completed,\n  failed: checkResult.failed,\n  elapsed_ms: checkResult.elapsed_ms,\n  is_timeout: checkResult.is_timeout,\n  extracted_data: extracted,\n  raw_results: results\n};"
      },
      "id": "12593bcf-de63-4343-aedf-0cd68435b288",
      "name": "Collect Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -352
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nreturn {\n  action: 'no_tasks',\n  appeal_id: data.appeal_id,\n  tenant_id: data.tenant_id,\n  has_extracted_data: data.has_extracted_data,\n  active_device: data.active_device,\n  extracted_data: {\n    brand: data.active_device?.brand_name,\n    brand_id: data.active_device?.brand_id,\n    model: data.active_device?.model_name,\n    model_id: data.active_device?.model_id,\n    repair_category: data.active_device?.repairs?.[0]?.category_name,\n    repair_category_id: data.active_device?.repairs?.[0]?.category_id\n  }\n};"
      },
      "id": "29dc7e82-1d4d-4ef0-90f5-72706b782d2c",
      "name": "No Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        272,
        -256
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE appeals SET\n  brand_id = (SELECT id FROM brands WHERE LOWER(name) = LOWER('{{ $json.extracted_data.brand }}') LIMIT 1),\n  model_id = (SELECT id FROM models WHERE LOWER(name) = LOWER('{{ $json.extracted_data.model }}') LIMIT 1),\n  repair_type_id = (SELECT id FROM repair_types WHERE LOWER(name) = LOWER('{{ $json.extracted_data.repair_category[0] }}') LIMIT 1),\n  problem_description = '{{ $json.extracted_data.repair_action }}',\n  parts_owner = COALESCE(NULLIF('{{ $json.extracted_data.parts_owner }}', 'null'), 'workshop'),\n  stage = CASE \n    WHEN '{{ $json.extracted_data.appeal_type }}' IN ('greeting', 'spam', 'consultation') THEN 'Первичный контакт'\n    ELSE 'Информация собрана'\n  END,\n  updated_at = NOW()\nWHERE id = '{{ $json.appeal_id }}'::uuid;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1824,
        -352
      ],
      "id": "11d96dc6-75f9-4fe6-a516-1223339670fa",
      "name": "Update Appeal",
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Input": {
      "main": [
        [
          {
            "node": "Load Appeal Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Appeal Data": {
      "main": [
        [
          {
            "node": "Get Neo4j Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Neo4j Context": {
      "main": [
        [
          {
            "node": "Prepare Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Tasks": {
      "main": [
        [
          {
            "node": "Has Tasks?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Tasks?": {
      "main": [
        [
          {
            "node": "Push to Redis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Push to Redis": {
      "main": [
        [
          {
            "node": "Set Batch Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Batch Status": {
      "main": [
        [
          {
            "node": "Init Wait Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Wait Loop": {
      "main": [
        [
          {
            "node": "Poll DB Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Poll DB Status": {
      "main": [
        [
          {
            "node": "Check Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Completion": {
      "main": [
        [
          {
            "node": "Continue Polling?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Polling?": {
      "main": [
        [
          {
            "node": "Wait 300ms",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 300ms": {
      "main": [
        [
          {
            "node": "Poll DB Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Results": {
      "main": [
        [
          {
            "node": "Update Appeal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "tags": [
    {
      "id": "8zD9sDD78ytgu5T2",
      "name": "BattCRM"
    },
    {
      "id": "JkzPlhYcdcsJtFGG",
      "name": "Tool"
    }
  ]
}
