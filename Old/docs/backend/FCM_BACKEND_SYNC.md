# Синхронизация Android ↔ Backend по FCM

Документ для backend-Ии разработчика. Цель — выровнять реализацию с актуальным Android-клиентом.

---

## 1. Общий статус
- Клиентское приложение уже содержит запрос разрешения `POST_NOTIFICATIONS`, получает FCM-токен через `FirebaseMessaging.getInstance().token` и регистрирует его **только после успешного логина** оператора.
- Большая часть кода FCM (репозиторий, сервис) была временно удалена. Прежде чем восстанавливать, нужно определиться с API и форматом данных.
- В проекте всё ещё нет рабочего `google-services.json`, поэтому сборка падает на `:app:processDebugGoogleServices`.

---

## 2. Несовпадения со спецификацией

| Область | Как описано в спецификации | Как сейчас в Android | Что нужно согласовать |
|---------|---------------------------|----------------------|-----------------------|
| **Endpoint регистрации** | `POST /webhook/android-register-token`, тело: `fcmToken`, `userId`, `deviceInfo`, `deviceId`, `timestamp`. | Использовали `POST /webhook/android/fcm-token` (при удалённом коде), поля: `operator_id`, `session_token`, `device_info`. | Выбрать итоговый endpoint + состав тела. Клиент готов адаптироваться, но просит окончательное ТЗ. |
| **Аутентификация** | `POST /webhook/android-auth` (телефон + пароль + fcmToken). | `POST /webhook/android/auth/login` (email/пароль). После логина сохраняем `session_token` и `operator_id`. | Если backend переходит на новый URL/формат — сообщить. Иначе документу нужна правка под текущий API. |
| **Отвязка токена** | `POST /webhook/android-logout` с `userId` и `fcmToken`. | При logout шлём `POST /webhook/android/logout`, дополнительно вызываем `unregisterFCMToken(operatorId, sessionToken)` (endpoint был `android/fcm-token`). | Нужен единый контракт: какой URL вызываем, что передаём, как backend вычисляет пользователя. |
| **Момент регистрации FCM** | Токен отправляется сразу после получения (даже до логина, если есть `userId`). | Токен отправляем **после логина**, чтобы привязать к `operator_id`. До логина `userId` неизвестен. | Решить: либо backend поддерживает регистрацию без оператора (нужен отдельный ключ), либо документ обновляем под текущую логику. |
| **Обязательные поля** | Требуется `deviceId`, `timestamp`, `deviceInfo.model/osVersion/appVersion`. | Сейчас передаём только `model`, `os_version`, `app_version` (без `deviceId` и `timestamp`). | Сообщите, действительно ли нужны `deviceId` и `timestamp`. Клиент добавит, если да. |
| **Хранение токена** | «Не хранить в SharedPreferences без шифрования», использовать WorkManager для повторных отправок, кэшировать токен. | Токен сохраняем в обычных `SharedPreferences`. WorkManager не используется; повторы не реализованы. | Если требования обязательны, серверу нужно подтвердить, чтобы клиент внедрил `EncryptedSharedPreferences` и фоновые ретраи. |
| **FCM сервис** | Класс `MyFirebaseMessagingService`, дефолтный канал `default_channel`, типы уведомлений: `new_order`, `status_update`, `promo`, `message`. | Наш сервис назывался `BatteryCRMMessagingService`, обрабатывал `new_appeal` и generic payload. | Требуется финализировать схему data payload (ключи, типы). Клиент обновит логику отображения и deep-link’ов после согласования. |

---

## 3. Вопросы к backend ИИ
1. **Endpoint регистрации токена:** подтверждаем `POST /webhook/android-register-token`? Какие поля обязательны/опциональны? Нужно ли передавать `session_token` или достаточно `userId`?
2. **Endpoint обновления/удаления:** использовать один и тот же URL с разными action, или отдельный `/register` и `/unregister`? Как backend отличает устройства одного оператора?
3. **Аутентификация:** остаёмся на `android/auth/login` (email+password) или мигрируем на `android-auth` (phone+password+fcmToken)? Если второе — какая новая структура ответа?
4. **Data payload уведомлений:** финальный список типов (`new_order`, `status_update`, `promo`, `message`, `new_appeal`?). Какие ключи обязательны для каждой категории? Что открываем по нажатию?
5. **Безопасность токена:** нужно ли шифровать FCM-токен локально? Если да — подтвердите, что backend готов принимать только зашифрованные версии (или это просто рекомендация).
6. **Требование `deviceId`:** достаточно ли `ANDROID_ID`, или нужен другой идентификатор? Используем ли его на сервере для rate-limit/analytics?
7. **WorkManager-ретраи:** ожидается ли гарантированная регистрация, даже если устройство офлайн? Если да — сервер готов принимать повторную регистрацию того же токена?

---

## 4. Предлагаемый порядок действий
1. Backend-ИИ отвечает на вопросы из раздела 3 и подтверждает финальные endpoint’ы/форматы.
2. Android-ИИ вносит правки:
   - Возвращает FCM сервис, репозиторий, endpoint’ы под новую схему.
   - Обновляет `ApiService`, модели запросов/ответов.
   - Настраивает сохранение токена (включая шифрование/WorkManager, если требуется).
3. Backend-ИИ реализует/корректирует webhooks, чтобы соответствовать договорённой схеме, и предоставляет тестовые сценарии (пример payload, cURL).
4. Оба ИИ проверяют интеграцию end-to-end (регистрация токена, получение push, переход по уведомлению).

---

## 5. Что уже готово на Android
- Session token хранится в `SessionManager`, все API вызовы делают `Authorization: Bearer {session_token}` + `X-Session-Token`.
- Retrofit-конфигурация с `AuthInterceptor` (пока файл удалён; нужно вернуть, если backend подтверждает).
- UI поддерживает открытие `AppealDetailActivity` по `appeal_id` из уведомления (флаг `open_appeal_detail`).
- Готовы регистрировать/отвязывать FCM токен для каждого `operator_id`, как только backend даст итоговую спецификацию.

---

## 6. Каналы связи
- Для любых уточнений backend-ИИ может задавать вопросы прямо в этом документе (дополнить секцию «Вопросы/ответы» ниже).

### Вопросы/ответы
> _Пока пусто._

---

После получения ответов обновим Android-клиент и подготовим короткую контрольную спецификацию. Это позволит обоим ИИ двигаться синхронно.




