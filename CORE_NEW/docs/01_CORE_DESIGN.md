# CORE_NEW: Проектирование ядра системы

## Миссия

**Eldoleado — CRM с единым клиентом.**

Все каналы коммуникации (telegram, whatsapp, vk, avito, звонки, визиты) привязаны к одному клиенту. Все касания отслеживаются и доступны в едином контексте.

**Инструменты системы:**
- **Отслеживание касаний** — каждое взаимодействие = touchpoint
- **Единый клиент** — все каналы привязаны к одному профилю
- **Удержание** — автоматические реакции на события (не пришёл, не ответил)
- **Обогащение** — сбор данных о клиенте из разных источников
- **Социальные связи** — граф связей между клиентами (семья, друзья, рефералы)

---

## Глоссарий терминов

### Бизнес-термины

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Вертикаль** | Отрасль/ниша бизнеса со своими сущностями, этапами воронки и правилами | Ремонт телефонов, автосервис, недвижимость, медицина |
| **Клиент (Client)** | Человек, который взаимодействует с бизнесом. Один клиент = один профиль, независимо от канала | Иван Петров (telegram + whatsapp + визит) |
| **Диалог (Dialog)** | Единица общения с клиентом. Содержит сообщения и контекст (устройство, проблема, цена) | Разговор про ремонт iPhone 14 |
| **Касание (Touchpoint)** | Любое взаимодействие клиента с бизнесом | Сообщение, звонок, визит, email, SMS, промо |
| **Устройство (Device)** | Объект, с которым работает бизнес (для ремонтных вертикалей) | iPhone 14 Pro, MacBook Air, Samsung S23 |
| **Проблема (Problem/Issue)** | Описание неисправности или запроса клиента | Разбит экран, не заряжается, замена батареи |
| **Сущность (Entity)** | Любой объект, извлекаемый из диалога | Устройство, проблема, цена, намерение |

### Архитектурные термины

| Термин | Определение | Где используется |
|--------|-------------|------------------|
| **Фокус (Focus)** | Текущая точка внимания в диалоге — на какое устройство/проблему направлен разговор | Context Builder определяет фокус автоматически |
| **Линия (Line)** | Полный путь от клиента до конкретной проблемы в графе | Client → Device → Problem |
| **Контекст (Context)** | Накопленное понимание диалога: устройство, проблема, цена, этап, ожидания | Хранится в elo_dialogs.context (JSONB) |
| **Мультиконтекст** | Ситуация, когда в диалоге несколько устройств/проблем одновременно | "У меня iPhone и Samsung, оба разбиты" |
| **Граф (Graph)** | Структура связей в Neo4j: клиенты, устройства, проблемы, отношения | Neo4j хранит связи, PostgreSQL — данные |
| **Tool (Инструмент)** | Атомарная AI-функция с одним промптом | device_extract, issue_extract, price_lookup |
| **Промпт (Prompt)** | Инструкция для AI, определяющая что извлекать/генерировать | "Извлеки бренд и модель устройства..." |

### Технические термины

| Термин | Определение | Значение |
|--------|-------------|----------|
| **Intent** | Цель/намерение обращения клиента | REPAIR, PURCHASE, QUESTION, SALE, SPAM |
| **Stage** | Этап воронки/диалога | NEW, QUOTED, SCHEDULED, IN_PROGRESS, DELIVERED |
| **ai_freedom_level** | Уровень свободы AI в принятии решений (0-100) | 0 = только правила, 100 = полная свобода |
| **Prompt-in-Request** | Принцип: промпты передаются в запросе, не хардкодятся | Гибкость без деплоя |
| **Stateless** | Компонент без состояния — вся информация в запросе | Горизонтальное масштабирование |

---

## Философия

**Всё есть касание (touchpoint).** Клиент взаимодействует с сервисом через касания — сообщения, звонки, визиты, промо.

**Устройства — центр системы.** Вся история, все проблемы, все касания привязаны к устройству (для ремонтных вертикалей).

**Контекст общий.** Если Иван принёс телефон жены — вся история по этому телефону доступна и Ивану, и жене.

**Граф хранит связи**, PostgreSQL хранит данные.

**Социальные связи = рост.** Друг привёл друга → связь в графе → потенциал для реферальных программ.

---

## Блоки ядра системы

### Обзор архитектуры

```
┌─────────────────────────────────────────────────────────────────┐
│                          КЛИЕНТ                                  │
│                   (Telegram, WhatsApp, ...)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MCP КАНАЛЫ                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    CONTEXT BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    REQUEST BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      ORCHESTRATOR                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    UNIVERSAL TOOLS                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    DIALOG ENGINE                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   RESPONSE BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MCP КАНАЛЫ                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                          КЛИЕНТ                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### Описание блоков

#### 1. MCP КАНАЛЫ (Message Channel Providers)

**Что делает:**
- Принимает сообщения из мессенджеров (Telegram, WhatsApp, VK, Avito, MAX)
- Отправляет ответы клиентам
- Преобразует форматы сообщений в унифицированный внутренний формат

**Входные данные:**
- Сообщение от клиента во внешнем формате

**Выходные данные:**
```json
{
  "channel": "telegram",
  "external_chat_id": "123456789",
  "message": "iPhone 14, разбит экран",
  "client_identifier": {"telegram_id": "123456789"},
  "timestamp": "2024-12-09T10:30:00Z"
}
```

**Характеристики:** Stateless, горизонтально масштабируемый

---

#### 2. CONTEXT BUILDER (Сборщик контекста)

**Что делает:**
- Собирает полный контекст для обработки сообщения
- Запрашивает данные из PostgreSQL (диалог, клиент, история)
- Запрашивает данные из Neo4j (связи, устройства, активные проблемы)
- Определяет ФОКУС диалога (на какое устройство/проблему направлен разговор)

**Входные данные:**
- Унифицированное сообщение от MCP
- client_id или идентификатор канала

**Выходные данные:**
```json
{
  "message": "Алло, это по поводу айфона",
  "client": {"id": "uuid", "name": "Иван"},
  "dialog": {"id": "uuid", "status": "active"},
  "graph_context": {
    "active_devices": [
      {"id": "uuid", "model": "iPhone 14 Pro", "owner": "self", "active_problem": "экран"},
      {"id": "uuid", "model": "iPhone 13", "owner": "жена", "active_problem": "экран"}
    ],
    "relations": [{"name": "Мария", "type": "spouse"}]
  },
  "focus": {
    "ambiguous": true,
    "candidates": ["iPhone 14 Pro", "iPhone 13"]
  },
  "history": [...]
}
```

**Ключевая роль:**
- Граф → Context Builder: "У клиента 2 iPhone с активными проблемами"
- Context Builder определяет: нужно уточнение фокуса

**Характеристики:** Stateless

---

#### 3. REQUEST BUILDER (Сборщик запроса)

**Что делает:**
- Загружает конфигурацию вертикали (required_tools, forbidden_tools)
- Применяет ВХОДНЫЕ ПРАВИЛА (кнут) — обязательные и запрещённые tools
- Применяет AI-ЛОГИКУ (пряник) — выбор дополнительных tools, адаптация
- Применяет ВЫХОДНЫЕ ПРАВИЛА (кнут) — валидация, whitelist, лимиты
- Формирует полный запрос для Orchestrator

**Входные данные:**
- unified_context от Context Builder
- tenant_id, vertical_id

**Выходные данные:**
```json
{
  "message": "iPhone 14, разбит экран",
  "context": {...},
  "orchestrator_prompt": "Ты обрабатываешь обращения в сервис ремонта...",
  "tools": [
    {
      "name": "device_extract",
      "description": "Извлекает устройство",
      "prompt": "Извлеки бренд и модель...",
      "output_schema": {...}
    },
    {
      "name": "issue_extract",
      "description": "Извлекает проблему",
      "prompt": "Определи категорию неисправности...",
      "output_schema": {...}
    }
  ]
}
```

**Принцип "Кнут-Пряник-Кнут":**
```
ВХОДНЫЕ ПРАВИЛА (жёсткие)
        │
        ▼
   AI-ЛОГИКА (свобода = ai_freedom_level)
        │
        ▼
ВЫХОДНЫЕ ПРАВИЛА (валидация)
```

**Характеристики:** Stateless, содержит бизнес-логику выбора tools

---

#### 4. ORCHESTRATOR (Оркестратор)

**Что делает:**
- Получает запрос с промптом и списком tools
- Решает какие tools вызвать и в каком порядке
- Вызывает tools, передаёт данные между ними
- Агрегирует результаты

**Входные данные:**
- Полный запрос от Request Builder (message, context, prompt, tools[])

**Выходные данные:**
```json
{
  "results": [
    {"tool": "device_extract", "output": {"brand": "Apple", "model": "iPhone 14"}},
    {"tool": "issue_extract", "output": {"category": "Дисплей", "description": "разбит"}}
  ],
  "final_context": {
    "device": {"brand": "Apple", "model": "iPhone 14"},
    "issue": {"category": "Дисплей"},
    "stage": "quoted",
    "price": 15000
  }
}
```

**Ключевой принцип: СЛЕПОЙ**
- НЕ ЗНАЕТ про другие tools (видит только переданные в запросе)
- НЕ ЗНАЕТ бизнес-логику (только выполняет)
- Всё знание — в запросе

**Характеристики:** Stateless, AI-управляемый

---

#### 5. UNIVERSAL TOOLS (Универсальные инструменты)

**Что делает:**
- Выполняет один промпт
- Возвращает результат по заданной схеме
- Не знает бизнес-логику — только промпт

**Входные данные:**
```json
{
  "message": "iPhone 14, разбит экран",
  "prompt": "Извлеки из сообщения информацию об устройстве. Верни JSON: {brand, model}",
  "output_schema": {"brand": "string", "model": "string"}
}
```

**Выходные данные:**
```json
{
  "brand": "Apple",
  "model": "iPhone 14"
}
```

**Примеры tools:**

| Tool | Назначение | Prompt (упрощённо) |
|------|------------|-------------------|
| `device_extract` | Извлечь устройство | "Найди бренд и модель..." |
| `issue_extract` | Извлечь проблему | "Определи категорию неисправности..." |
| `intent_classify` | Классифицировать намерение | "Определи цель обращения: REPAIR/PURCHASE/QUESTION..." |
| `price_lookup` | Найти цену | Не AI, запрос в БД |
| `response_generate` | Сгенерировать ответ | "Сформируй ответ клиенту..." |
| `sentiment_analyze` | Определить настроение | "Оцени эмоциональный тон..." |

**Ключевой принцип: ЕЩЁ СЛЕПЕЕ**
- Знает только свой промпт
- Один worker обрабатывает ВСЕ вертикали (разница в промпте)

**Характеристики:** Stateless, горизонтально масштабируемый

---

#### 6. DIALOG ENGINE (Движок диалогов)

**Что делает:**
- Сохраняет результаты в elo_dialogs.context
- Записывает события в elo_events
- Синхронизирует новые факты в Neo4j (граф)
- Обновляет статистику клиента

**Входные данные:**
- Результаты от Orchestrator
- dialog_id, client_id

**Действия:**
```sql
-- Обновить контекст диалога
UPDATE elo_dialogs
SET context = context || '{"device": {"brand": "Apple"}, "stage": "quoted"}'
WHERE id = $dialog_id;

-- Записать событие
INSERT INTO elo_events (dialog_id, event_type, data)
VALUES ($dialog_id, 'context_extracted', '{"device": "iPhone 14"}');
```

**Синхронизация в граф:**
```cypher
// Создать/обновить устройство
MERGE (d:Device {id: $device_id})
SET d.brand = "Apple", d.model = "iPhone 14"

// Связать с клиентом
MATCH (c:Client {id: $client_id})
MERGE (c)-[:OWNS]->(d)

// Создать проблему
CREATE (p:Problem {id: $problem_id, category: "Дисплей", stage: "NEW"})
MERGE (d)-[:HAS_PROBLEM]->(p)
```

**Характеристики:** Хранит состояние, source of truth

---

#### 7. RESPONSE BUILDER (Формирователь ответа)

**Что делает:**
- Генерирует ответ клиенту на основе контекста
- Форматирует под конкретный канал (кнопки для Telegram, etc.)
- Добавляет AI-подсказки для оператора (если не автоответ)

**Входные данные:**
- final_context от Orchestrator
- channel (telegram/whatsapp/...)
- mode (auto/assist)

**Выходные данные:**
```json
{
  "text": "Замена экрана iPhone 14 — 15000₽, займёт 1 час. Записать на сегодня?",
  "buttons": [
    {"text": "Да, записать", "callback": "schedule_yes"},
    {"text": "Уточнить", "callback": "schedule_later"}
  ],
  "suggestions_for_operator": [
    "Клиент VIP, можно предложить скидку 10%"
  ]
}
```

**Характеристики:** Stateless

---

## Взаимодействие блоков

### Полный поток данных

```
КЛИЕНТ: "iPhone 14, разбит экран"
         │
         ▼
    MCP КАНАЛ
    (унификация)
         │
         ▼
  CONTEXT BUILDER ◄───────────► NEO4J (граф)
  (сбор контекста)              (связи, устройства)
         │
         │ unified_context
         ▼
  REQUEST BUILDER
  (правила + AI + валидация)
         │
         │ {message, context, prompt, tools[]}
         ▼
   ORCHESTRATOR
   (вызов tools)
         │
         ├──► device_extract  → {brand: "Apple", model: "iPhone 14"}
         ├──► issue_extract   → {category: "Дисплей"}
         ├──► price_lookup    → {price: 15000}
         │
         │ final_context
         ▼
  DIALOG ENGINE ────────────► NEO4J (синхронизация)
  (сохранение)                (новые факты)
         │
         ▼
  RESPONSE BUILDER
  (форматирование)
         │
         ▼
    MCP КАНАЛ
    (отправка)
         │
         ▼
      КЛИЕНТ: "Замена экрана iPhone 14 — 15000₽..."
```

---

## Ключевые концепции

### ЛИНИЯ в графе

Линия — это путь от клиента до конкретной проблемы. Цель Context Builder — определить и достроить линию.

**Тип "ремонт":**
```
Client ──→ Device ──→ Problem
  │           │          │
  │           │          └── "разбит экран"
  │           └── "iPhone 14 Pro"
  └── Иван
```

**Тип "консультация":**
```
Client ──→ Question
             └── "сколько стоит ремонт экрана"
```

**Тип "покупка":**
```
Client ──→ Item
             └── "чехол на iPhone 14"
```

### ФОКУС диалога

Фокус — текущая точка внимания в диалоге.

```javascript
focus: {
  client_id: "uuid",
  device_id: "uuid",           // текущее устройство (или null)
  problem_id: "uuid",          // текущая проблема (или null)
  ambiguous: false,            // требуется ли уточнение
  candidates: []               // варианты если ambiguous=true
}
```

**Пример неоднозначного фокуса:**
```
Клиент: "Алло, это по поводу айфона"

focus: {
  ambiguous: true,
  candidates: ["iPhone 14 Pro (экран)", "iPhone 13 жены (экран)"]
}

→ Ответ: "У вас два iPhone в работе. Какой имеете в виду?"
```

### МУЛЬТИКОНТЕКСТ

Ситуация, когда в одном диалоге несколько устройств/проблем.

```
Клиент: "У меня iPhone 14 — разбит экран, и Samsung S23 — не заряжается"

context: {
  devices: [
    {brand: "Apple", model: "iPhone 14", issue: "экран"},
    {brand: "Samsung", model: "S23", issue: "зарядка"}
  ],
  is_multi_device: true
}
```

**Обработка:** Orchestrator вызывает tools для каждого устройства, результаты агрегируются.

### Общий контекст устройства

Устройство — центр. Все касания по устройству видны всем связанным людям.

```
┌─────────────────────────────────────────────────────────────────┐
│                     DEVICE (iPhone 13)                          │
│  ─────────────────────────────────────────────────────────────  │
│  owner: Мария                                                   │
│  связан: Иван (муж) - принёс на ремонт                         │
│                                                                 │
│  ВСЯ ИСТОРИЯ ПО УСТРОЙСТВУ (независимо кто писал):             │
│  ├── [Иван] "у жены iPhone 13 разбит экран"                    │
│  ├── [Бот → Иван] "Оригинал или копия дисплея?"                │
│  ├── [Иван] "жена сама выберет"                                │
│  ├── [Бот → Мария] "Муж принёс ваш iPhone 13. Какой дисплей?"  │
│  └── [Мария] "копию поставьте"                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Связи в графе

### Типы связей клиент-клиент

| Связь | Описание |
|-------|----------|
| `SPOUSE` | Супруг/супруга |
| `PARENT_OF` | Родитель |
| `CHILD_OF` | Ребёнок |
| `FRIEND` | Друг |
| `COLLEAGUE` | Коллега |
| `REFERRED_BY` | Привёл (реферал) |

### Типы связей клиент-устройство

| Связь | Описание |
|-------|----------|
| `OWNS` | Владелец |
| `BROUGHT_FOR_REPAIR` | Принёс на ремонт (не владелец) |
| `MANAGES` | Управляет (IT для корпоративных) |
| `USES` | Пользуется (но не владеет) |

### Диаграмма графа

```
                    Device (iPhone 13)
                           │
          ┌────────────────┼────────────────┐
          │                │                │
     [:OWNS]         [:BROUGHT_BY]    [:HAS_PROBLEM]
          │                │                │
          ▼                ▼                ▼
       Мария            Иван            Problem
       (owner)        (accessor)        (экран)
          │                │
          └───[:SPOUSE]────┘
```

---

## Принятые решения

### R1: Цели обращений (Intent)

| Intent | Описание | Требует устройства |
|--------|----------|-------------------|
| `REPAIR` | Ремонт устройства | Да |
| `PURCHASE` | Покупка товара/услуги | Опционально |
| `SALE` | Клиент хочет продать | Да |
| `QUESTION` | Вопрос (цены, график) | Нет |
| `SPAM` | Спам/реклама | Нет |
| `UNCLEAR` | Непонятно | Нет |

### R2: Этапы воронки (Stage)

Для вертикали "ремонт телефонов":

```
NEW → QUOTED → SCHEDULED → RECEIVED → IN_PROGRESS → READY → DELIVERED
                                                       ↓
                                                   CANCELLED
```

| Stage | Описание |
|-------|----------|
| `NEW` | Новое обращение |
| `QUOTED` | Озвучена цена |
| `SCHEDULED` | Записан на визит |
| `RECEIVED` | Устройство принято |
| `IN_PROGRESS` | В работе |
| `READY` | Готово к выдаче |
| `DELIVERED` | Выдано |
| `CANCELLED` | Отменено |

### R3: Определение владельца

1. **По умолчанию:** кто написал = владелец
2. **Если указано:** "телефон жены" → ищем связь в графе
3. **Если не найден:** создаём placeholder, уточняем позже

---

## Следующие шаги

1. [x] Описать глоссарий терминов
2. [x] Описать блоки ядра
3. [x] Описать концепции (линия, фокус, мультиконтекст)
4. [x] Спроектировать схему PostgreSQL → `02_DATABASE_SCHEMA.md`
5. [x] Спроектировать схему Neo4j → `03_NEO4J_SCHEMA.md`
6. [x] Определить API контракты → `04_API_CONTRACTS.md`
7. [x] Описать AI архитектуру → `05_AI_ARCHITECTURE.md`
8. [ ] Создать SQL миграции
9. [ ] Переписать Core workflows

---

**Автор:** User + Claude Code
**Обновлено:** 2025-12-09
**Версия:** 2.0
