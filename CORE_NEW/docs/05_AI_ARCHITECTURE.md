# CORE_NEW: AI Архитектура

## Философия

**Ядро универсальное. Вертикали — конфигурация.**

Один движок обрабатывает любые вертикали (ремонт техники, автосервис, недвижимость).
Вся бизнес-логика — в промптах и правилах в БД, не в коде.

---

## Архитектура: Сверху вниз

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                     УРОВЕНЬ 0: ДАННЫЕ                        │
│                                                              │
│  ┌─────────────────────┐    ┌─────────────────────┐         │
│  │    PostgreSQL       │    │      Neo4j          │         │
│  │                     │    │                     │         │
│  │ • elo_dialogs       │    │ • Client            │         │
│  │ • elo_clients       │    │ • Device            │         │
│  │ • elo_events        │    │ • Problem           │         │
│  │ • ai_tools          │    │                     │         │
│  │ • ai_prompts        │    │ Связи:              │         │
│  │ • verticals         │    │ • OWNS              │         │
│  │ • vertical_settings │    │ • SPOUSE, FAMILY    │         │
│  │                     │    │ • REFERRED_BY       │         │
│  │                     │    │ • HAS_PROBLEM       │         │
│  └─────────────────────┘    └─────────────────────┘         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                УРОВЕНЬ 1: CONTEXT BUILDER                    │
│                    (Сборщик контекста)                       │
│                                                              │
│  Вход: message + client_id + channel                        │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ PostgreSQL запросы:                                 │    │
│  │ • Текущий диалог (elo_dialogs)                     │    │
│  │ • История сообщений (elo_events)                   │    │
│  │ • Данные клиента (elo_clients)                     │    │
│  └─────────────────────────────────────────────────────┘    │
│                          +                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ Neo4j запросы:                                      │    │
│  │ • Устройства клиента и его сети                    │    │
│  │ • Активные проблемы                                │    │
│  │ • Связанные клиенты (семья, рефералы)              │    │
│  │ • Похожие кейсы                                    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
│  Выход: unified_context {}                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                УРОВЕНЬ 2: REQUEST BUILDER                    │
│                        (Мозг)                                │
│                                                              │
│  Вход: message + unified_context + tenant_id                │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 1. ВХОДНЫЕ ПРАВИЛА (кнут)                           │    │
│  │    • required_tools — обязательные инструменты      │    │
│  │    • forbidden_tools — запрещённые                  │    │
│  │    • Жёсткие ограничения ДО AI                      │    │
│  └─────────────────────────────────────────────────────┘    │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 2. AI-ЛОГИКА (пряник)                               │    │
│  │    • Выбор дополнительных tools                     │    │
│  │    • Определение порядка выполнения                 │    │
│  │    • Адаптация под контекст                         │    │
│  │    • Свобода = ai_freedom_level (0-100)             │    │
│  └─────────────────────────────────────────────────────┘    │
│                          │                                   │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ 3. ВЫХОДНЫЕ ПРАВИЛА (кнут)                          │    │
│  │    • Проверка whitelist                             │    │
│  │    • Лимит количества tools                         │    │
│  │    • Валидация и санитизация                        │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
│  Выход: {                                                   │
│    message,                                                 │
│    context,                                                 │
│    orchestrator_prompt,                                     │
│    tools: [{name, description, prompt}, ...]                │
│  }                                                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                 УРОВЕНЬ 3: ORCHESTRATOR                      │
│                     (Исполнитель)                            │
│                                                              │
│  Вход: полный запрос от Request Builder                     │
│                                                              │
│  • Получает промпт и список tools В ЗАПРОСЕ                 │
│  • НЕ ЗНАЕТ про другие tools (видит только переданные)      │
│  • Решает какие вызвать и в каком порядке                   │
│  • Передаёт данные между tools                              │
│  • Агрегирует результаты                                    │
│                                                              │
│  Принцип: СЛЕПОЙ — работает только с тем, что дали          │
│                                                              │
│  Выход: {results[], final_context}                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                  УРОВЕНЬ 4: UNIVERSAL TOOLS                  │
│                (Универсальные рабочие)                       │
│                                                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │
│  │ device  │  │ issue   │  │ intent  │  │ price   │  ...   │
│  │ extract │  │ extract │  │ classify│  │ lookup  │        │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │
│                                                              │
│  Каждый tool:                                               │
│  • Получает {message, prompt, schema} в запросе             │
│  • Выполняет промпт — НЕ ЗНАЕТ бизнес-логику               │
│  • Возвращает результат по schema                           │
│                                                              │
│  Принцип: ЕЩЁ СЛЕПЕЕ — выполняет один промпт               │
│                                                              │
│  Один worker обрабатывает ВСЕ вертикали                     │
│  (разница только в промпте)                                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                УРОВЕНЬ 5: DIALOG ENGINE                      │
│                   (Хранилище)                                │
│                                                              │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                   elo_dialogs                          │  │
│  │                                                        │  │
│  │  • messages[] — история сообщений                     │  │
│  │  • context {} — извлечённые сущности (JSONB)          │  │
│  │  • events[] — таймлайн событий                        │  │
│  │  • state — текущее состояние диалога                  │  │
│  └───────────────────────────────────────────────────────┘  │
│                                                              │
│  Результаты tools → мержатся в context                      │
│  Новые факты → синхронизируются в Neo4j                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│               УРОВЕНЬ 6: RESPONSE BUILDER                    │
│                   (Формирование ответа)                      │
│                                                              │
│  Вход: context + результаты tools                           │
│                                                              │
│  • Генерирует ответ клиенту                                 │
│  • Форматирует под канал (Telegram/WhatsApp/Avito...)       │
│  • Добавляет кнопки, медиа если нужно                       │
│                                                              │
│  Выход: {text, buttons?, media?}                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                УРОВЕНЬ 7: MCP КАНАЛЫ                         │
│                  (Мессенджеры)                               │
│                                                              │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐    │
│  │Telegram│ │WhatsApp│ │ Avito  │ │   VK   │ │  MAX   │    │
│  └────────┘ └────────┘ └────────┘ └────────┘ └────────┘    │
│                                                              │
│  • Получают сообщения от клиентов                           │
│  • Отправляют ответы клиентам                               │
│  • Унифицированный формат внутри системы                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                      КЛИЕНТ                                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Граф + Context Extractor: Симбиоз

### Двусторонняя связь

```
┌─────────────────┐         ┌─────────────────┐
│    NEO4J        │◄────────│ Context         │
│    ГРАФ         │         │ Extractor       │
│                 │────────►│                 │
│  Даёт контекст  │         │ Обогащает граф  │
└─────────────────┘         └─────────────────┘
```

**Граф → Extractor:**
- "жена" → Мария (конкретный uuid)
- iPhone 13 → уже есть в системе (не дубль)
- История: была проблема с батареей 3 месяца назад

**Extractor → Граф:**
- Новый факт: iPhone 13 — разбит экран
- Новая связь: Иван принёс устройство жены
- Обновление: статус проблемы

### Практический пример

**Сообщение от Ивана:**
```
"Алло, это по поводу айфона"
```

**Без графа (слепой extractor):**
```
{device: "iPhone", issue: null}
→ Какой iPhone? Чей? Какая проблема?
→ Нужно задавать вопросы
```

**С графом (умный extractor):**
```cypher
MATCH (c:Client {telegram_id: "123"})-[:OWNS|BROUGHT_FOR_REPAIR]->(d:Device)
MATCH (d)-[:HAS_PROBLEM]->(p:Problem)
WHERE p.stage NOT IN ['DELIVERED', 'CANCELLED']
RETURN d, p
```

```
→ Результат:
  - iPhone 14 Pro (мой) — экран, IN_PROGRESS
  - iPhone 13 (жены) — экран, WAITING

→ Ответ: "У вас два iPhone в работе. Какой — ваш 14 Pro или жены 13?"
```

### Роли

| Компонент | Роль | Аналогия |
|-----------|------|----------|
| **Граф** | Память системы | Долговременная память |
| **Extractor** | Восприятие | Глаза и уши |
| **Граф → Extractor** | Контекст | "Я знаю эту жену — это Мария" |
| **Extractor → Граф** | Обогащение | "Новый факт: экран разбит" |

---

## Ключевой принцип: Prompt-in-Request

Вместо хардкода промптов — передаём их в запросе.

### Структура запроса к Orchestrator

```json
{
  "dialog_id": "uuid",
  "message": "iPhone 14, разбит экран, сколько стоит?",
  "context": {
    "client": {"id": "uuid", "name": "Иван"},
    "active_devices": [...],
    "history": [...]
  },

  "orchestrator_prompt": "Ты обрабатываешь обращения в сервис ремонта...",

  "tools": [
    {
      "name": "device_extract",
      "description": "Извлекает информацию об устройстве",
      "prompt": "Извлеки из сообщения: бренд, модель. Верни JSON...",
      "output_schema": {"brand": "string", "model": "string"}
    },
    {
      "name": "issue_extract",
      "description": "Извлекает проблему/неисправность",
      "prompt": "Определи категорию неисправности...",
      "output_schema": {"category": "string", "description": "string"}
    },
    {
      "name": "price_lookup",
      "description": "Ищет цену в прайс-листе",
      "prompt": null,
      "params": {"brand": "{{device.brand}}", "model": "{{device.model}}"}
    }
  ]
}
```

### Что это даёт

| Аспект | Преимущество |
|--------|--------------|
| **Изоляция** | Tenant A не видит tools tenant B |
| **Безопасность** | Нельзя вызвать tool вне списка |
| **Гибкость** | Каждый запрос — своя конфигурация |
| **Stateless** | Orchestrator без состояния |
| **Тестирование** | Подменил tools — другое поведение |

---

## Вертикали: Конфигурация, не код

### Таблица вертикалей

```sql
CREATE TABLE verticals (
  id UUID PRIMARY KEY,
  name VARCHAR,                  -- 'phone_repair', 'auto_service'
  display_name VARCHAR,          -- 'Ремонт телефонов'

  -- Какие сущности извлекать
  entities JSONB,                -- ['device', 'issue', 'price']

  -- Схема context для elo_dialogs
  context_schema JSONB,

  -- Промпт оркестратора по умолчанию
  default_orchestrator_prompt TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Настройки жёсткости (ai_freedom_level)

```sql
CREATE TABLE vertical_settings (
  id UUID PRIMARY KEY,
  vertical_id UUID REFERENCES verticals(id),
  tenant_id UUID,                        -- NULL = дефолт для вертикали

  -- Входные правила (кнут)
  required_tools VARCHAR[],              -- Всегда включать
  forbidden_tools VARCHAR[],             -- Никогда не включать

  -- AI-свобода (пряник)
  ai_freedom_level INT DEFAULT 50,       -- 0-100
  ai_can_skip_optional BOOLEAN,          -- Может ли AI пропустить
  ai_can_reorder BOOLEAN,                -- Может ли менять порядок
  ai_max_additional_tools INT,           -- Сколько может добавить

  -- Выходные правила (кнут)
  max_total_tools INT DEFAULT 5,
  tool_whitelist VARCHAR[]               -- Разрешённые tools
);
```

### Примеры настроек

**Жёсткая вертикаль (банк):**
```json
{
  "ai_freedom_level": 10,
  "required_tools": ["identity_verify", "compliance_check"],
  "forbidden_tools": ["auto_response"],
  "ai_can_skip_optional": false
}
```

**Свободная вертикаль (ремонт):**
```json
{
  "ai_freedom_level": 70,
  "required_tools": ["issue_extract"],
  "forbidden_tools": [],
  "ai_can_skip_optional": true,
  "ai_max_additional_tools": 5
}
```

### Визуализация

```
Жёсткость                                          Свобода
    ◄──────────────────────────────────────────────────►

    [████████░░]  Банк         ai_freedom = 10
    [███░░░░░░░]  Медицина     ai_freedom = 20
    [█████░░░░░]  Ремонт       ai_freedom = 50
    [███████░░░]  Консалтинг   ai_freedom = 70
    [█████████░]  A/B тест     ai_freedom = 90
```

---

## Библиотека Tools

### Таблица инструментов

```sql
CREATE TABLE ai_tools (
  id UUID PRIMARY KEY,
  name VARCHAR UNIQUE,              -- 'device_extract'
  display_name VARCHAR,             -- 'Извлечение устройства'
  description TEXT,                 -- Для оркестратора

  -- Промпт (шаблон с переменными)
  prompt_template TEXT,

  -- Схемы данных
  input_schema JSONB,
  output_schema JSONB,

  -- Категоризация
  category VARCHAR,                 -- 'extraction', 'lookup', 'generation'
  tags VARCHAR[],                   -- ['repair', 'auto', 'common']

  -- Для каких вертикалей
  vertical_ids UUID[],              -- NULL = для всех

  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Таблица промптов (специфичные для вертикали)

```sql
CREATE TABLE ai_prompts (
  id UUID PRIMARY KEY,
  tool_id UUID REFERENCES ai_tools(id),
  vertical_id UUID REFERENCES verticals(id),

  -- Промпт для конкретной вертикали
  prompt_template TEXT NOT NULL,

  -- Версионирование
  version INT DEFAULT 1,
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Примеры tools

**device_extract для ремонта:**
```
Извлеки из сообщения информацию об устройстве.
Доступные бренды: {{brands}}
Верни JSON: {brand, model, color}
```

**device_extract для автосервиса:**
```
Извлеки из сообщения информацию об автомобиле.
Верни JSON: {make, model, year, vin}
```

**Один tool — разные промпты для вертикалей.**

---

## Поток данных

```
КЛИЕНТ
   │
   │ "iPhone 14, разбит экран"
   ▼
MCP КАНАЛ (Telegram)
   │
   │ {message, chat_id, channel}
   ▼
CONTEXT BUILDER
   │
   │ PostgreSQL: диалог, клиент, история
   │ Neo4j: устройства, связи, активные проблемы
   │
   │ → unified_context
   ▼
REQUEST BUILDER
   │
   │ 1. Входные правила (required_tools)
   │ 2. AI-логика (выбор tools)
   │ 3. Выходные правила (whitelist)
   │
   │ → {message, context, orchestrator_prompt, tools[]}
   ▼
ORCHESTRATOR
   │
   │ Вызывает tools по очереди:
   ├──► device_extract  → {brand: "Apple", model: "iPhone 14"}
   ├──► issue_extract   → {category: "Дисплей", problem: "разбит"}
   ├──► price_lookup    → {price: 15000, duration: "1 час"}
   │
   │ → {results, final_context}
   ▼
DIALOG ENGINE
   │
   │ Сохраняет в elo_dialogs.context
   │ Синхронизирует в Neo4j (новые факты)
   ▼
RESPONSE BUILDER
   │
   │ Генерирует ответ
   │ Форматирует под канал
   │
   │ → {text, buttons}
   ▼
MCP КАНАЛ (Telegram)
   │
   │ Отправляет ответ
   ▼
КЛИЕНТ

   "Замена экрана iPhone 14 — 15000₽, займёт 1 час.
    Записать на сегодня?"
```

---

## Резюме уровней

| Уровень | Название | Роль | Stateless |
|---------|----------|------|-----------|
| 0 | Данные | PostgreSQL + Neo4j | — |
| 1 | Context Builder | Собирает контекст из PG + граф | ✅ |
| 2 | Request Builder | Мозг. Правила + AI + Правила | ✅ |
| 3 | Orchestrator | Исполнитель. Слепой — видит только запрос | ✅ |
| 4 | Universal Tools | Рабочие. Ещё слепее — один промпт | ✅ |
| 5 | Dialog Engine | Хранилище. elo_dialogs + sync в граф | — |
| 6 | Response Builder | Форматирование ответа | ✅ |
| 7 | MCP Каналы | Мессенджеры | ✅ |

---

## Принципы архитектуры

### 1. Ядро универсальное
Один код обрабатывает любые вертикали. Вся бизнес-логика — в промптах и правилах в БД.

### 2. Prompt-in-Request
Tools и Orchestrator получают промпты в запросе, не из кода. Переконфигурация без деплоя.

### 3. Кнут-Пряник-Кнут
Жёсткие правила → AI-свобода → Валидация. Регулируется ai_freedom_level.

### 4. Слепые исполнители
Чем ниже уровень, тем меньше знает компонент. Сложность наверху, простота внизу.

### 5. Граф = Память
Neo4j хранит связи и знания. Context Extractor обогащает и обогащается графом.

### 6. Stateless Pipeline
Каждый запрос — полный контекст. Горизонтальное масштабирование.

---

## Следующие шаги

1. [ ] Создать таблицы: `ai_tools`, `ai_prompts`, `vertical_settings`
2. [ ] Реализовать Context Builder (PG + Neo4j)
3. [ ] Реализовать Request Builder (правила + AI)
4. [ ] Создать Universal Worker (n8n workflow)
5. [ ] Мигрировать существующие промпты в БД
6. [ ] Интегрировать с MCP каналами

---

**Автор:** User + Claude Code
**Дата:** 2025-12-09
**Версия:** 1.0
