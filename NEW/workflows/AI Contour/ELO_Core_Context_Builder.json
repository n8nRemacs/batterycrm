{
  "name": "ELO_Core_Context_Builder",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "elo-core-context-builder",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "elo-core-context-builder"
    },
    {
      "parameters": {
        "jsCode": "const body = $json.body || $json;\nconst clientId = body.client_id || null;\nconst dialogId = body.dialog_id || null;\nconst action = body.action || 'get_context';\n\n// For match_entities action\nconst extracted = body.extracted || {};\nconst brand = extracted.brand || null;\nconst model = extracted.model || null;\nconst ownerLabel = extracted.owner_label || null;\nconst problemType = extracted.problem_type || null;\nconst currentFocus = body.current_focus || {};\n\n// Generate trace_id\nconst traceId = body.trace_id || `trace_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;\n\nreturn {\n  clientId,\n  dialogId,\n  action,\n  extracted: {\n    brand,\n    model,\n    ownerLabel,\n    problemType\n  },\n  currentFocus,\n  traceId\n};"
      },
      "id": "parse-request",
      "name": "Parse Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "get_context",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "get_context"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "disambiguation",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "disambiguation"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "match_entities",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "match_entities"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.action }}",
                    "rightValue": "load_dialog_context",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "load_dialog"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-by-action",
      "name": "Route by Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [690, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://45.144.177.128:7474/db/neo4j/tx/commit",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  statements: [{\n    statement: `\n      MATCH (c:Client {id: $clientId})\n      OPTIONAL MATCH (c)-[:OWNS]->(d:Device)\n      OPTIONAL MATCH (d)-[:HAS_PROBLEM]->(p:Problem)-[:OF_TYPE]->(pt:ProblemType)\n      OPTIONAL MATCH (c)-[:HAS_CHANNEL]->(ch:Channel)\n      OPTIONAL MATCH (c)-[:CUSTOMER_OF]->(v:Vertical)\n      OPTIONAL MATCH (t:Touchpoint)-[:ABOUT_DEVICE]->(d)\n      WHERE t.timestamp > datetime() - duration('P7D')\n      RETURN c, \n             collect(DISTINCT {id: d.id, brand: d.brand, model: d.model, owner_label: d.owner_label}) as devices,\n             collect(DISTINCT {id: p.id, status: p.status, type: pt.code}) as problems,\n             collect(DISTINCT {type: ch.type, identifier: ch.identifier}) as channels,\n             collect(DISTINCT v.type) as verticals\n    `,\n    parameters: { clientId: $json.clientId }\n  }]\n}) }}",
        "options": {
          "allowUnauthorizedCerts": true,
          "timeout": 30000
        }
      },
      "id": "neo4j-get-context",
      "name": "Neo4j Get Context",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [910, 100],
      "credentials": {
        "httpBasicAuth": {
          "id": "neo4j-auth",
          "name": "Neo4j"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://45.144.177.128:7474/db/neo4j/tx/commit",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  statements: [{\n    statement: `\n      MATCH (c:Client {id: $clientId})-[:OWNS]->(d:Device)\n      OPTIONAL MATCH (t:Touchpoint)-[:ABOUT_DEVICE]->(d)\n      WHERE t.timestamp > datetime() - duration('P1D')\n      WITH d, max(t.timestamp) as lastMentioned, count(t) as mentionCount\n      OPTIONAL MATCH (d)-[:HAS_PROBLEM]->(p:Problem {status: 'in_progress'})\n      RETURN d.id as id, \n             d.brand as brand, \n             d.model as model, \n             d.owner_label as owner_label,\n             lastMentioned,\n             mentionCount,\n             p IS NOT NULL as hasActiveRepair\n      ORDER BY \n        CASE WHEN lastMentioned IS NOT NULL THEN 0 ELSE 1 END,\n        lastMentioned DESC,\n        hasActiveRepair DESC,\n        mentionCount DESC\n    `,\n    parameters: { clientId: $json.clientId }\n  }]\n}) }}",
        "options": {
          "allowUnauthorizedCerts": true,
          "timeout": 30000
        }
      },
      "id": "neo4j-disambiguation",
      "name": "Neo4j Disambiguation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [910, 250],
      "credentials": {
        "httpBasicAuth": {
          "id": "neo4j-auth",
          "name": "Neo4j"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://45.144.177.128:7474/db/neo4j/tx/commit",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  statements: [{\n    statement: `\n      MATCH (c:Client {id: $clientId})-[:OWNS]->(d:Device)\n      WHERE ($brand IS NULL OR toLower(d.brand) CONTAINS toLower($brand))\n        AND ($model IS NULL OR toLower(d.model) CONTAINS toLower($model))\n        AND ($ownerLabel IS NULL OR toLower(d.owner_label) = toLower($ownerLabel))\n      OPTIONAL MATCH (d)-[:HAS_PROBLEM]->(p:Problem)\n      WHERE $problemType IS NULL OR p.type = $problemType\n      OPTIONAL MATCH (t:Touchpoint)-[:ABOUT_DEVICE]->(d)\n      WHERE t.timestamp > datetime() - duration('P1D')\n      WITH d, \n           collect(DISTINCT {id: p.id, type: p.type, status: p.status}) as problems,\n           max(t.timestamp) as lastMentioned,\n           count(t) as mentionCount\n      RETURN d.id as deviceId,\n             d.brand as brand,\n             d.model as model,\n             d.owner_label as ownerLabel,\n             problems,\n             lastMentioned,\n             mentionCount\n      ORDER BY \n        CASE WHEN lastMentioned IS NOT NULL THEN 0 ELSE 1 END,\n        lastMentioned DESC,\n        mentionCount DESC\n    `,\n    parameters: { \n      clientId: $json.clientId,\n      brand: $json.extracted.brand,\n      model: $json.extracted.model,\n      ownerLabel: $json.extracted.ownerLabel,\n      problemType: $json.extracted.problemType\n    }\n  }]\n}) }}",
        "options": {
          "allowUnauthorizedCerts": true,
          "timeout": 30000
        }
      },
      "id": "neo4j-match-entities",
      "name": "Neo4j Match Entities",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [910, 400],
      "credentials": {
        "httpBasicAuth": {
          "id": "neo4j-auth",
          "name": "Neo4j"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=dialog:{{$json.dialogId}}"
      },
      "id": "redis-load-context",
      "name": "Redis Load Context",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [910, 550],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "ELO_Redis"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const result = $json;\nconst data = result.results?.[0]?.data?.[0]?.row || [];\nconst traceId = $('Parse Request').first().json.traceId;\n\nreturn {\n  success: true,\n  client: data[0],\n  devices: data[1] || [],\n  problems: data[2] || [],\n  channels: data[3] || [],\n  verticals: data[4] || [],\n  trace_id: traceId\n};"
      },
      "id": "format-context",
      "name": "Format Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 100]
    },
    {
      "parameters": {
        "jsCode": "const result = $json;\nconst data = result.results?.[0]?.data || [];\nconst traceId = $('Parse Request').first().json.traceId;\n\nconst devices = data.map(d => ({\n  id: d.row[0],\n  brand: d.row[1],\n  model: d.row[2],\n  owner_label: d.row[3],\n  lastMentioned: d.row[4],\n  mentionCount: d.row[5],\n  hasActiveRepair: d.row[6]\n}));\n\nlet needsClarification = false;\nlet suggestedDevice = null;\nlet clarificationReason = null;\n\nif (devices.length === 0) {\n  needsClarification = false;\n} else if (devices.length === 1) {\n  suggestedDevice = devices[0];\n} else {\n  const recentlyMentioned = devices.filter(d => d.lastMentioned);\n  \n  if (recentlyMentioned.length === 1) {\n    suggestedDevice = recentlyMentioned[0];\n  } else if (recentlyMentioned.length > 1) {\n    needsClarification = true;\n    clarificationReason = 'multiple_mentioned_today';\n  } else {\n    const withActiveRepair = devices.filter(d => d.hasActiveRepair);\n    if (withActiveRepair.length === 1) {\n      suggestedDevice = withActiveRepair[0];\n    } else {\n      needsClarification = true;\n      clarificationReason = 'none_mentioned_recently';\n    }\n  }\n}\n\nreturn {\n  success: true,\n  devices,\n  needsClarification,\n  suggestedDevice,\n  clarificationReason,\n  trace_id: traceId\n};"
      },
      "id": "format-disambiguation",
      "name": "Format Disambiguation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 250]
    },
    {
      "parameters": {
        "jsCode": "const result = $json;\nconst inputData = $('Parse Request').first()?.json || {};\nconst extracted = inputData.extracted || {};\nconst currentFocus = inputData.currentFocus || {};\nconst traceId = inputData.traceId;\n\nconst data = result.results?.[0]?.data || [];\n\nconst matchedDevices = data.map(d => ({\n  deviceId: d.row[0],\n  brand: d.row[1],\n  model: d.row[2],\n  ownerLabel: d.row[3],\n  problems: d.row[4] || [],\n  lastMentioned: d.row[5],\n  mentionCount: d.row[6]\n}));\n\nlet deviceAction = 'create_new';\nlet matchedDeviceId = null;\nlet matchedDevice = null;\nlet problemAction = 'create_new';\nlet matchedProblemId = null;\nlet needsClarification = false;\nlet clarificationReason = null;\n\nif (!extracted.brand && !extracted.model) {\n  if (currentFocus.device_id) {\n    deviceAction = 'use_focus';\n    matchedDeviceId = currentFocus.device_id;\n  } else if (matchedDevices.length === 1) {\n    deviceAction = 'use_existing';\n    matchedDeviceId = matchedDevices[0].deviceId;\n    matchedDevice = matchedDevices[0];\n  } else if (matchedDevices.length > 1) {\n    deviceAction = 'needs_clarification';\n    needsClarification = true;\n    clarificationReason = 'multiple_devices_no_context';\n  }\n} else if (matchedDevices.length === 0) {\n  deviceAction = 'create_new';\n} else if (matchedDevices.length === 1) {\n  deviceAction = 'use_existing';\n  matchedDeviceId = matchedDevices[0].deviceId;\n  matchedDevice = matchedDevices[0];\n} else {\n  const recentlyMentioned = matchedDevices.filter(d => d.lastMentioned);\n  \n  if (recentlyMentioned.length === 1) {\n    deviceAction = 'use_existing';\n    matchedDeviceId = recentlyMentioned[0].deviceId;\n    matchedDevice = recentlyMentioned[0];\n  } else {\n    deviceAction = 'needs_clarification';\n    needsClarification = true;\n    clarificationReason = 'multiple_similar_devices';\n  }\n}\n\nif (extracted.problemType && matchedDevice) {\n  const existingProblem = matchedDevice.problems.find(\n    p => p.type === extracted.problemType && p.status !== 'closed'\n  );\n  \n  if (existingProblem) {\n    problemAction = 'use_existing';\n    matchedProblemId = existingProblem.id;\n  } else {\n    problemAction = 'create_new';\n  }\n} else if (!extracted.problemType) {\n  problemAction = 'none';\n}\n\nreturn {\n  success: true,\n  device: {\n    action: deviceAction,\n    matched_id: matchedDeviceId,\n    matched_device: matchedDevice,\n    all_matches: matchedDevices\n  },\n  problem: {\n    action: problemAction,\n    matched_id: matchedProblemId\n  },\n  needs_clarification: needsClarification,\n  clarification_reason: clarificationReason,\n  extracted,\n  current_focus: currentFocus,\n  trace_id: traceId\n};"
      },
      "id": "format-match-result",
      "name": "Format Match Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 400]
    },
    {
      "parameters": {
        "jsCode": "const redisResult = $json;\nconst inputData = $('Parse Request').first()?.json || {};\nconst traceId = inputData.traceId;\nconst dialogId = inputData.dialogId;\n\nlet dialogContext = null;\nlet found = false;\n\nif (redisResult.value) {\n  try {\n    dialogContext = JSON.parse(redisResult.value);\n    found = true;\n  } catch (e) {\n    dialogContext = null;\n  }\n}\n\nreturn {\n  success: true,\n  found: found,\n  dialog_id: dialogId,\n  context: dialogContext,\n  trace_id: traceId\n};"
      },
      "id": "format-dialog-context",
      "name": "Format Dialog Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 550]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1350, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Request": {
      "main": [
        [
          {
            "node": "Route by Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Action": {
      "main": [
        [
          {
            "node": "Neo4j Get Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Neo4j Disambiguation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Neo4j Match Entities",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redis Load Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Get Context": {
      "main": [
        [
          {
            "node": "Format Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Disambiguation": {
      "main": [
        [
          {
            "node": "Format Disambiguation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Match Entities": {
      "main": [
        [
          {
            "node": "Format Match Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis Load Context": {
      "main": [
        [
          {
            "node": "Format Dialog Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Dialog Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Disambiguation": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Match Result": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Dialog Context": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "",
  "meta": {
    "instanceId": ""
  },
  "tags": [
    {
      "name": "ELO_Core_AI"
    }
  ]
}
