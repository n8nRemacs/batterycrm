{
  "name": "ELO_Core_Lines_Analyzer",
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "path": "elo-core-lines-analyzer",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "elo-core-lines-analyzer"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\n\nreturn {\n  context: input.context,\n  entities: input.extractions?.entities || [],\n  changes: {\n    lines_created: 0,\n    lines_updated: 0,\n    focus_changed: false\n  }\n};"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300]
    },
    {
      "parameters": {
        "jsCode": "const context = $json.context;\nconst entities = $json.entities;\nlet changes = $json.changes;\n\n// Slot order for cursor calculation\nconst SLOT_ORDER = ['device', 'symptom', 'diagnosis', 'repair_type', 'price'];\n\n// Helper: find line by device match\nfunction findLineByDevice(lines, brand, model) {\n  return lines.find(line => {\n    const dev = line.slots?.device;\n    if (!dev) return false;\n    // Fuzzy match: same brand and model contains\n    const brandMatch = dev.brand?.toLowerCase() === brand?.toLowerCase();\n    const modelMatch = dev.model?.toLowerCase().includes(model?.toLowerCase()) ||\n                       model?.toLowerCase().includes(dev.model?.toLowerCase());\n    return brandMatch && modelMatch;\n  });\n}\n\n// Helper: create new line\nfunction createLine(lines, device) {\n  return {\n    id: `line_${lines.length}`,\n    status: 'waiting',\n    cursor: 1, // After device (device is index 0)\n    slots: {\n      device: {\n        brand: device.brand,\n        model: device.model,\n        color: device.color || null\n      },\n      symptom: null,\n      symptom_type: null,\n      diagnosis: null,\n      repair_type: null,\n      price: null\n    }\n  };\n}\n\n// Helper: fill slot and move cursor\nfunction fillSlot(line, slotName, value) {\n  const slotIndex = SLOT_ORDER.indexOf(slotName);\n  \n  // Only fill if empty\n  if (!line.slots[slotName]) {\n    line.slots[slotName] = value;\n    \n    // Move cursor if this slot is at or before cursor\n    if (slotIndex >= 0 && slotIndex <= line.cursor) {\n      line.cursor = Math.max(line.cursor, slotIndex + 1);\n    }\n    return true;\n  }\n  return false;\n}\n\n// Helper: check if line is complete (stage 1)\nfunction isLineComplete(line) {\n  const requiredSlots = ['device', 'symptom'];\n  return requiredSlots.every(slot => line.slots[slot] !== null);\n}\n\n// Process each entity\nconst deviceEntities = entities.filter(e => e.type === 'device');\nconst otherEntities = entities.filter(e => e.type !== 'device');\n\n// Step 1: Process devices (may create new lines)\nfor (const device of deviceEntities) {\n  if (!device.brand && !device.model) continue;\n  \n  const existingLine = findLineByDevice(context.lines, device.brand, device.model);\n  \n  if (!existingLine) {\n    // Create new line for this device\n    const newLine = createLine(context.lines, device);\n    context.lines.push(newLine);\n    changes.lines_created++;\n  } else {\n    // Update existing line's device info if more specific\n    if (device.model && device.model.length > (existingLine.slots.device?.model?.length || 0)) {\n      existingLine.slots.device.model = device.model;\n    }\n    if (device.color && !existingLine.slots.device.color) {\n      existingLine.slots.device.color = device.color;\n    }\n    changes.lines_updated++;\n  }\n}\n\n// Step 2: Process other entities (symptoms, etc.)\nfor (const entity of otherEntities) {\n  let targetLine = null;\n  \n  // Find target line\n  if (entity.for_device) {\n    // Entity specifies device - find matching line\n    targetLine = context.lines.find(line => {\n      const dev = line.slots?.device;\n      return dev && entity.for_device.toLowerCase().includes(dev.model?.toLowerCase());\n    });\n  }\n  \n  // Fallback: use focus line or first line\n  if (!targetLine) {\n    if (context.focus_line_id) {\n      targetLine = context.lines.find(l => l.id === context.focus_line_id);\n    }\n    if (!targetLine && context.lines.length > 0) {\n      targetLine = context.lines[0];\n    }\n  }\n  \n  if (targetLine) {\n    // Fill appropriate slot\n    if (entity.type === 'symptom') {\n      const filled = fillSlot(targetLine, 'symptom', {\n        text: entity.text,\n        confidence: entity.confidence || 0.8\n      });\n      if (filled) changes.lines_updated++;\n    }\n    // Add other entity types here...\n  }\n}\n\n// Step 3: Update line statuses\nfor (const line of context.lines) {\n  if (isLineComplete(line)) {\n    line.status = 'done';\n  } else if (line.id === context.focus_line_id) {\n    line.status = 'active';\n  } else {\n    line.status = 'waiting';\n  }\n}\n\n// Step 4: Manage focus\nconst focusLine = context.lines.find(l => l.id === context.focus_line_id);\nif (!focusLine || focusLine.status === 'done') {\n  const nextWaiting = context.lines.find(l => l.status === 'waiting');\n  if (nextWaiting) {\n    nextWaiting.status = 'active';\n    context.focus_line_id = nextWaiting.id;\n    changes.focus_changed = true;\n  } else if (context.lines.length > 0 && !context.focus_line_id) {\n    // No focus set - use first line\n    context.lines[0].status = 'active';\n    context.focus_line_id = context.lines[0].id;\n    changes.focus_changed = true;\n  }\n}\n\n// Update completed_lines\ncontext.completed_lines = context.lines\n  .filter(l => l.status === 'done')\n  .map(l => l.id);\n\nreturn {\n  context: context,\n  changes: changes\n};"
      },
      "id": "process-entities",
      "name": "Process Entities",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [690, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [910, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Process Entities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Entities": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "",
  "meta": {
    "instanceId": ""
  },
  "tags": [
    {
      "name": "ELO_Core_AI"
    }
  ]
}
