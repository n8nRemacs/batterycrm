package com.google.crypto.tink.subtle;

import com.google.crypto.tink.Aead;
import com.google.crypto.tink.config.internal.TinkFipsUtil;
import java.security.GeneralSecurityException;
import java.util.Arrays;
import javax.crypto.AEADBadTagException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/* loaded from: classes6.dex */
public final class AesEaxJce implements Aead {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    static final int BLOCK_SIZE_IN_BYTES = 16;
    static final int TAG_SIZE_IN_BYTES = 16;

    /* renamed from: b, reason: collision with root package name */
    private final byte[] f360678b;
    private final int ivSizeInBytes;
    private final SecretKeySpec keySpec;

    /* renamed from: p, reason: collision with root package name */
    private final byte[] f360679p;
    public static final TinkFipsUtil.AlgorithmFipsCompatibility FIPS = TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS;
    private static final ThreadLocal<Cipher> localEcbCipher = new ThreadLocal<Cipher>() { // from class: com.google.crypto.tink.subtle.AesEaxJce.1
        @Override // java.lang.ThreadLocal
        public Cipher initialValue() {
            try {
                return EngineFactory.CIPHER.getInstance("AES/ECB/NOPADDING");
            } catch (GeneralSecurityException e12) {
                throw new IllegalStateException(e12);
            }
        }
    };
    private static final ThreadLocal<Cipher> localCtrCipher = new ThreadLocal<Cipher>() { // from class: com.google.crypto.tink.subtle.AesEaxJce.2
        @Override // java.lang.ThreadLocal
        public Cipher initialValue() {
            try {
                return EngineFactory.CIPHER.getInstance("AES/CTR/NOPADDING");
            } catch (GeneralSecurityException e12) {
                throw new IllegalStateException(e12);
            }
        }
    };

    public AesEaxJce(byte[] bArr, int i12) throws GeneralSecurityException {
        if (!FIPS.isCompatible()) {
            throw new GeneralSecurityException("Can not use AES-EAX in FIPS-mode.");
        }
        if (i12 != 12 && i12 != 16) {
            throw new IllegalArgumentException("IV size should be either 12 or 16 bytes");
        }
        this.ivSizeInBytes = i12;
        Validators.validateAesKeySize(bArr.length);
        SecretKeySpec secretKeySpec = new SecretKeySpec(bArr, "AES");
        this.keySpec = secretKeySpec;
        Cipher cipher = localEcbCipher.get();
        cipher.init(1, secretKeySpec);
        byte[] bArrMultiplyByX = multiplyByX(cipher.doFinal(new byte[16]));
        this.f360678b = bArrMultiplyByX;
        this.f360679p = multiplyByX(bArrMultiplyByX);
    }

    private static byte[] multiplyByX(byte[] bArr) {
        byte[] bArr2 = new byte[16];
        int i12 = 0;
        while (i12 < 15) {
            int i13 = i12 + 1;
            bArr2[i12] = (byte) (((bArr[i12] << 1) ^ ((bArr[i13] & 255) >>> 7)) & 255);
            i12 = i13;
        }
        bArr2[15] = (byte) (((bArr[0] >> 7) & 135) ^ (bArr[15] << 1));
        return bArr2;
    }

    private byte[] omac(Cipher cipher, int i12, byte[] bArr, int i13, int i14) throws BadPaddingException, IllegalBlockSizeException {
        byte[] bArr2 = new byte[16];
        bArr2[15] = (byte) i12;
        if (i14 == 0) {
            return cipher.doFinal(xor(bArr2, this.f360678b));
        }
        byte[] bArrDoFinal = cipher.doFinal(bArr2);
        int i15 = 0;
        while (i14 - i15 > 16) {
            for (int i16 = 0; i16 < 16; i16++) {
                bArrDoFinal[i16] = (byte) (bArrDoFinal[i16] ^ bArr[(i13 + i15) + i16]);
            }
            bArrDoFinal = cipher.doFinal(bArrDoFinal);
            i15 += 16;
        }
        return cipher.doFinal(xor(bArrDoFinal, pad(Arrays.copyOfRange(bArr, i15 + i13, i13 + i14))));
    }

    private byte[] pad(byte[] bArr) {
        if (bArr.length == 16) {
            return xor(bArr, this.f360678b);
        }
        byte[] bArrCopyOf = Arrays.copyOf(this.f360679p, 16);
        for (int i12 = 0; i12 < bArr.length; i12++) {
            bArrCopyOf[i12] = (byte) (bArrCopyOf[i12] ^ bArr[i12]);
        }
        bArrCopyOf[bArr.length] = (byte) (bArrCopyOf[bArr.length] ^ 128);
        return bArrCopyOf;
    }

    private static byte[] xor(byte[] bArr, byte[] bArr2) {
        int length = bArr.length;
        byte[] bArr3 = new byte[length];
        for (int i12 = 0; i12 < length; i12++) {
            bArr3[i12] = (byte) (bArr[i12] ^ bArr2[i12]);
        }
        return bArr3;
    }

    @Override // com.google.crypto.tink.Aead
    public byte[] decrypt(byte[] bArr, byte[] bArr2) throws GeneralSecurityException {
        int length = (bArr.length - this.ivSizeInBytes) - 16;
        if (length < 0) {
            throw new GeneralSecurityException("ciphertext too short");
        }
        Cipher cipher = localEcbCipher.get();
        cipher.init(1, this.keySpec);
        byte[] bArrOmac = omac(cipher, 0, bArr, 0, this.ivSizeInBytes);
        if (bArr2 == null) {
            bArr2 = new byte[0];
        }
        byte[] bArr3 = bArr2;
        byte[] bArrOmac2 = omac(cipher, 1, bArr3, 0, bArr3.length);
        byte[] bArrOmac3 = omac(cipher, 2, bArr, this.ivSizeInBytes, length);
        int length2 = bArr.length - 16;
        byte b12 = 0;
        for (int i12 = 0; i12 < 16; i12++) {
            b12 = (byte) (b12 | (((bArr[length2 + i12] ^ bArrOmac2[i12]) ^ bArrOmac[i12]) ^ bArrOmac3[i12]));
        }
        if (b12 != 0) {
            throw new AEADBadTagException("tag mismatch");
        }
        Cipher cipher2 = localCtrCipher.get();
        cipher2.init(1, this.keySpec, new IvParameterSpec(bArrOmac));
        return cipher2.doFinal(bArr, this.ivSizeInBytes, length);
    }

    @Override // com.google.crypto.tink.Aead
    public byte[] encrypt(byte[] bArr, byte[] bArr2) throws GeneralSecurityException {
        int length = bArr.length;
        int i12 = this.ivSizeInBytes;
        if (length > 2147483631 - i12) {
            throw new GeneralSecurityException("plaintext too long");
        }
        byte[] bArr3 = new byte[bArr.length + i12 + 16];
        byte[] bArrRandBytes = Random.randBytes(i12);
        System.arraycopy(bArrRandBytes, 0, bArr3, 0, this.ivSizeInBytes);
        Cipher cipher = localEcbCipher.get();
        cipher.init(1, this.keySpec);
        byte[] bArrOmac = omac(cipher, 0, bArrRandBytes, 0, bArrRandBytes.length);
        byte[] bArr4 = bArr2 == null ? new byte[0] : bArr2;
        byte[] bArrOmac2 = omac(cipher, 1, bArr4, 0, bArr4.length);
        Cipher cipher2 = localCtrCipher.get();
        cipher2.init(1, this.keySpec, new IvParameterSpec(bArrOmac));
        cipher2.doFinal(bArr, 0, bArr.length, bArr3, this.ivSizeInBytes);
        byte[] bArrOmac3 = omac(cipher, 2, bArr3, this.ivSizeInBytes, bArr.length);
        int length2 = bArr.length + this.ivSizeInBytes;
        for (int i13 = 0; i13 < 16; i13++) {
            bArr3[length2 + i13] = (byte) ((bArrOmac2[i13] ^ bArrOmac[i13]) ^ bArrOmac3[i13]);
        }
        return bArr3;
    }
}
