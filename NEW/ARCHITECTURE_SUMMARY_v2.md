# ELDOLEADO: Полное Summary архитектуры v2

> Документ для продолжения работы без потери контекста
> Дата: 2025-12-10

---

## 1. ФИЛОСОФИЯ СИСТЕМЫ

### 1.1 Миссия

**Eldoleado — CRM с единым клиентом.**

Все каналы коммуникации (telegram, whatsapp, vk, avito, звонки, визиты) привязаны к одному клиенту. Все касания отслеживаются в едином контексте.

### 1.2 Ключевые принципы

| Принцип | Описание |
|---------|----------|
| **Люди общаются, машина ведёт учёт** | Человеку — естественное общение, машине — рутина и таблицы |
| **Диалогоцентричность** | Диалог — центральная сущность, не заявка |
| **Клиентоцентричность** | Один клиент = один профиль, независимо от канала |
| **Граф = источник истины** | Neo4j хранит связи, PostgreSQL — кэш для быстрого чтения |
| **Prompt-in-Request** | Промпты передаются в запросе, не хардкодятся |
| **Кнут-Пряник-Кнут** | Правила → AI-свобода → Валидация |
| **Накопление данных с первого клиента** | Всё пишем, обучение — потом |

### 1.3 Упрощение архитектуры

```
❌ Старый подход:
   Клиент → Заявки → Устройства → Проблемы (50 таблиц)

✅ Новый подход:
   Клиент → Диалоги (с контекстом внутри) (минимум таблиц)
```

**Метафора:** Живёшь в однушке, забил вещами. Думаешь: переедем в трёшку — разложимся. Переезжаешь — места опять нет. Проблема не в квартире. Проблема в хламе.

---

## 2. ВЕРТИКАЛИ

### 2.1 Концепция

**Вертикаль ≠ Тип сообщения.** Вертикаль = бизнес-модель.

| Вертикаль | Модель | Фокус | Статус |
|-----------|--------|-------|--------|
| **phone_repair** | Сервисная | Возвращаемость, LTV | ✅ MVP |
| **buy_sell** | Транзакционная | Конверсия, быстрый цикл | ⏳ Позже |

**Аналогия:** Стоматолог и продавец зубных щёток — оба «про зубы», но это не одна вертикаль.

### 2.2 Общее между вертикалями

- Один клиент может быть в обеих вертикалях
- Единый граф, разные срезы
- Кросс-продажи между вертикалями

### 2.3 Что вне вертикали

Всё, что не входит в компетенцию AI (залог, нестандартные запросы, купля-продажа на первом этапе) → **эскалация на оператора**.

---

## 3. СЕМЬ БЛОКОВ ЯДРА

### 3.1 Архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│                          КЛИЕНТ                                  │
│                   (Telegram, WhatsApp, ...)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MCP КАНАЛЫ                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    CONTEXT BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    REQUEST BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      ORCHESTRATOR                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    UNIVERSAL TOOLS                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    DIALOG ENGINE                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   RESPONSE BUILDER                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      MCP КАНАЛЫ                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Описание блоков

| # | Блок | Что делает | Характеристики |
|---|------|------------|----------------|
| 1 | **MCP Каналы** | Приём/отправка сообщений, унификация формата | Stateless |
| 2 | **Context Builder** | Сбор контекста из PostgreSQL + Neo4j, определение фокуса | Stateless |
| 3 | **Request Builder** | Правила + AI + валидация ("Кнут-Пряник-Кнут") | Stateless |
| 4 | **Orchestrator** | Слепой исполнитель, вызывает tools | Stateless, AI-управляемый |
| 5 | **Universal Tools** | Атомарные AI-функции (device_extract, issue_extract) | Stateless |
| 6 | **Dialog Engine** | Сохранение в БД, синхронизация в Neo4j | Source of truth |
| 7 | **Response Builder** | Форматирование ответа под канал | Stateless |

### 3.3 Ключевые принципы блоков

**Orchestrator — СЛЕПОЙ:**
- НЕ ЗНАЕТ про другие tools (видит только переданные в запросе)
- НЕ ЗНАЕТ бизнес-логику (только выполняет)
- Всё знание — в запросе

**Universal Tools — ЕЩЁ СЛЕПЕЕ:**
- Знает только свой промпт
- Один worker обрабатывает ВСЕ вертикали (разница в промпте)

---

## 4. ТРИ СЛОЯ ПРАВДЫ

### 4.1 Цепочка

```
Intake (контейнер слов клиента)
    │
    ├── Symptom 1 ("не заряжается")
    ├── Symptom 2 ("экран треснул")
    └── Symptom 3 ("батарея вздулась")
           │
           ▼
    Diagnosis (мастер нашёл)
           │
           ▼
    Repair (что сделали)
```

### 4.2 Определения

| Сущность | Источник | Описание |
|----------|----------|----------|
| **Intake** | Диалог | Контейнер — всё что клиент сказал при обращении |
| **Symptom** | AI extraction | Извлечённый симптом из слов клиента |
| **Diagnosis** | Мастер | Что реально нашли при диагностике |
| **Repair** | Мастер | Что сделали |

### 4.3 Зачем три слоя

| Проблема | Решение |
|----------|---------|
| Клиент говорит "не работает экран", а проблема в подсветке | Разделяем симптом и диагноз |
| Приёмщик ожидал одно, мастер нашёл другое | Фиксируем расхождение → обучаемся |
| Follow-up спрашивает "как новый дисплей?", а дисплей не меняли | Опираемся на REPAIR, не на SYMPTOM |
| Статистика цен по симптому врёт | Считаем по реальным ремонтам |

---

## 5. МИКРОВОРОНКА ДИАЛОГА

### 5.1 Концепция

Вместо "типа обращения" (Ремонт, Покупка, Консультация) — **микроворонка**:

```
👋 Приветствие → 📱 Устройство → 🔧 Проблема → 💰 Цена → 📅 Запись → 👋 Прощание
```

**Не 7 этапов продажи за месяц. А 7 микроэтапов за 15 минут.**

### 5.2 Почему не "тип обращения"

| Подход | Проблема |
|--------|----------|
| Тип обращения | Требует классификации в начале, клиент может не знать что хочет |
| Микроворонка | Ведёт клиента пошагово, определяет намерение по ходу |

### 5.3 Структура этапа

```json
{
  "code": "problem",
  "name": "Обсуждение проблемы",
  "position": 3,
  "entry_conditions": {
    "required_fields": ["device_model"]
  },
  "ai_goal": "Собрать симптомы: что не работает, когда началось",
  "ai_prompt": "Клиент рассказал про устройство {device}. Уточни проблему...",
  "auto_actions": {},
  "exit_conditions": {
    "any_of": ["symptom_text", "problem_category"]
  }
}
```

### 5.4 Стандартные этапы (вертикаль phone_repair)

| # | code | name | ai_goal |
|---|------|------|---------|
| 1 | greeting | Приветствие | Поздороваться, узнать имя |
| 2 | device | Устройство | Бренд, модель, цвет, владелец |
| 3 | problem | Проблема | Симптомы, когда началось |
| 4 | price | Цена | Озвучить стоимость |
| 5 | appointment | Запись | Дата/время визита |
| 6 | closing | Закрытие | Подтвердить, попрощаться |

### 5.5 Хранение текущего этапа

**PostgreSQL (dialogs.context):**
```json
{
  "current_stage": "problem",
  "stage_entered_at": "2025-12-10T10:30:00Z"
}
```

Минимум данных. Всё остальное — из графа.

---

## 6. FOCUS SCORE

### 6.1 Концепция

**focus_score** — процент заполненности контекста диалога (0-100%).

```
15% — только имя, непонятно что хочет
45% — есть устройство, нет проблемы
80% — всё понятно, уточняем детали
100% — полный контекст, можно работать
```

### 6.2 Зачем

- 👁 Быстрая ориентация — видишь сразу, где пробелы
- ⚡ Экономия ресурсов — при 100% не дёргаем лишние запросы к LLM
- 🎯 Не теряем недоделанные — не даём клиенту уйти, пока не дособрали инфу

### 6.3 Когда вычислять

**Триггеры пересчёта:**
- Создан Device → пересчёт
- Создан Symptom → пересчёт
- Привязан ProblemCategory → пересчёт

**НЕ триггеры:**
- Обычное сообщение без извлечений
- Сообщение оператора
- Уточнение деталей существующего Symptom

### 6.4 Почему НЕ хранить

1. **Граф = источник истины** — всегда актуальные данные
2. **15-20ms** — достаточно быстро для каждого запроса
3. **Нет рассинхрона** — не нужно инвалидировать кэш

### 6.5 Логика дожима

```
Диалог: 3 телефона обсудили
  📱 iPhone свой     → 100%
  📱 iPhone сына     → 100%
  📱 Samsung жены    → 75%

Среднее: 91.6% < 100%
  → Есть что дожать
  → Смотрим кто не 100%
  → Добираем инфу
```

**Пример:**
```
Клиент: «Ну всё, спасибо, до свидания»
Бот: «Подождите, вы не сказали что сломалось у Samsung жены. Уточните?»
```

---

## 7. ЛИНИЯ И ФОКУС ДИАЛОГА

### 7.1 Линия в графе

Линия — путь от клиента до конкретной проблемы:

```
Client → Device → ProblemCategory → Symptom
```

**Тип "ремонт":**
```
Client ──→ Device ──→ Issue ──→ Symptom
  │           │          │
  │           │          └── "разбит экран"
  │           └── "iPhone 14 Pro"
  └── Иван
```

### 7.2 Фокус диалога

Фокус — текущая точка внимания в диалоге.

```javascript
focus: {
  client_id: "uuid",
  device_id: "uuid",           // текущее устройство (или null)
  issue_id: "uuid",            // текущий issue (или null)
  ambiguous: false,            // требуется ли уточнение
  candidates: []               // варианты если ambiguous=true
}
```

### 7.3 Неоднозначный фокус

```
Клиент: "Алло, это по поводу айфона"

focus: {
  ambiguous: true,
  candidates: ["iPhone 14 Pro (экран)", "iPhone 13 жены (экран)"]
}

→ Ответ: "У вас два iPhone в работе. Какой имеете в виду?"
```

### 7.4 Мультиконтекст

Несколько устройств/проблем в одном диалоге:

```
Клиент: "У меня iPhone 14 — разбит экран, и Samsung S23 — не заряжается"

context: {
  devices: [
    {brand: "Apple", model: "iPhone 14", issue: "экран"},
    {brand: "Samsung", model: "S23", issue: "зарядка"}
  ],
  is_multi_device: true
}
```

---

## 8. ДИАГНОСТИЧЕСКИЙ ДВИЖОК

### 8.1 Концепция

Самообучающаяся экспертная система диагностики:
- Задаёт уточняющие вопросы на основе признаков/дефектов
- Предсказывает диагноз по комбинации признаков
- Обучается на расхождениях между ожиданием и фактом
- Накапливает экспертизу в графе знаний

### 8.2 Два потока обогащения знаний

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  TOP-DOWN (эксперт)              BOTTOM-UP (из расхождений)    │
│                                                                 │
│  • Типы симптомов                • Авто-триггер                │
│  • Признаки/дефекты              • Очередь анализа             │
│  • Уточняющие вопросы            • Резолюции                   │
│  • Деревья вопросов              • Новые знания                │
│                                                                 │
│             ▼                              ▼                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    БАЗА ЗНАНИЙ                           │   │
│  │   ELO_DefectSign ── ELO_SignPattern ── ELO_QuestionTree │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.3 Новые сущности диагностического движка

| Сущность | Назначение | MVP |
|----------|------------|-----|
| **ELO_DefectSign** | Признак с вопросом ("Беспроводная работает?") | ✅ |
| **ELO_SignCategory** | Категория признаков (charging, display, sound) | ✅ |
| **ELO_QuestionTree** | JSON дерево вопросов для адаптивного диалога | ✅ |
| **ELO_SignPattern** | Комбинация признаков → диагноз с вероятностью | ⏳ Позже |
| **ELO_Deviation** | Расхождение Intake vs Repair | ⏳ Инфраструктура |

### 8.4 Пример признаков (DefectSign)

**Категория: Зарядка (charging)**
```
charge_no_reaction — "Телефон вообще не реагирует на зарядку?"
charge_slow — "Заряжается очень медленно?"
other_cable_tried — "Другой кабель пробовали?"
wireless_works — "На беспроводной зарядке работает?"
water_contact — "Телефон был в воде?"
```

### 8.5 QuestionTree — JSON в узле

```json
{
  "root": {
    "sign": "charge_no_reaction",
    "question": "Телефон вообще не реагирует на зарядку?",
    "yes": {
      "sign": "other_cable_tried",
      "question": "Другой кабель пробовали?",
      "yes": {
        "sign": "wireless_works",
        "question": "На беспроводной зарядке работает?",
        "yes": {
          "conclusion": "charging_port",
          "confidence": 0.94
        }
      }
    }
  }
}
```

**Почему JSON:** Гибкость настройки per tenant, не хардкодим в графе.

### 8.6 Deviation — расхождение

**Автоматический триггер:** При создании Repair система сравнивает с Intake.

**Статус MVP:** Пишем в БД, анализ — потом (UI в браузере, не в app).

### 8.7 Приоритет реализации

- ✅ Сбор признаков в диалоге
- ✅ Intake при обращении
- ✅ Инфраструктура БД (таблицы, связи)
- ⏳ Deviation создаётся автоматически
- ⏳ Анализ расхождений — позже
- ⏳ Обучение на расхождениях — позже

---

## 9. PostgreSQL vs Neo4j

### 9.1 Формула

```
PostgreSQL (JSONB) = кэш (быстро читать)
Neo4j (граф) = источник истины (дёргаем при изменениях)
```

### 9.2 Логика работы

```
Новое сообщение
  ↓
LLM парсит → извлекает сущности
  ↓
Сравниваем с JSON в PostgreSQL
  ↓
┌─────────────────────────────────────┐
│ Новые сущности?                     │
│                                     │
│ НЕТ → Читаем JSON, граф не трогаем  │
│ ДА  → Идём в граф, обновляем JSON   │
└─────────────────────────────────────┘
```

### 9.3 Сравнение скорости

| | PostgreSQL (JSONB) | Neo4j (граф) |
|---|---|---|
| Операция | SELECT по ID | Traversal по рёбрам |
| Латентность | ~1-5 мс | ~5-20 мс |
| Что делает | Читает готовый JSON | Вычисляет связи |

### 9.4 Что где хранить

**PostgreSQL (обязательно):**
- Авторизация, сессии операторов
- Клиенты (для поиска, API)
- Диалоги (статус, текущий этап)
- Сообщения (вся история)
- Настройки тенантов
- Deviations (лог для анализа)

**Neo4j (обязательно):**
- Client (для связей)
- Device, Issue, Intake, Symptom, Diagnosis, Repair
- Все связи между сущностями
- DefectSign, QuestionTree, SignPattern
- Справочники типов

**ELO_Message в Neo4j:**
- **Только сообщения, которые меняют граф** (создали Device, Symptom и т.д.)
- Остальные — только в PostgreSQL

---

## 10. СХЕМА PostgreSQL

### 10.1 Минимальные таблицы

```sql
-- 1. Тенанты
tenants (
    id UUID PK,
    name VARCHAR,
    settings JSONB,
    created_at, updated_at
)

-- 2. Операторы
operators (
    id UUID PK,
    tenant_id UUID FK,
    name, email, username, password_hash,
    is_active BOOLEAN,
    created_at, updated_at
)

-- 3. Сессии операторов
operator_sessions (
    id UUID PK,
    operator_id UUID FK,
    tenant_id UUID FK,
    session_token VARCHAR UNIQUE,
    device_type VARCHAR,  -- mobile | web
    device_id VARCHAR,
    device_info JSONB,
    fcm_token VARCHAR,
    created_at, last_active_at
)

-- 4. Клиенты
clients (
    id UUID PK,
    tenant_id UUID FK,
    phone, telegram_id, whatsapp_id, vk_id, avito_id,
    name VARCHAR,
    first_seen_at, last_seen_at,
    created_at, updated_at
)

-- 5. Диалоги
dialogs (
    id UUID PK,
    tenant_id UUID FK,
    client_id UUID FK,
    channel VARCHAR,
    external_chat_id VARCHAR,
    current_stage VARCHAR,
    stage_entered_at TIMESTAMPTZ,
    status VARCHAR,  -- active | waiting | closed
    created_at, updated_at
)

-- 6. Сообщения
messages (
    id UUID PK,
    tenant_id UUID FK,
    dialog_id UUID FK,
    client_id UUID FK,
    timestamp TIMESTAMPTZ,
    direction VARCHAR,  -- inbound | outbound
    actor_type VARCHAR,  -- client | operator | ai
    actor_id UUID,
    content TEXT,
    has_media BOOLEAN,
    media_type VARCHAR,
    media_url TEXT,
    changed_graph BOOLEAN DEFAULT false,
    created_at
)

-- 7. Настройки тенанта
tenant_settings (
    id UUID PK,
    tenant_id UUID FK,
    key VARCHAR(100),
    value JSONB,
    version INT DEFAULT 1,
    previous_version_id UUID FK,
    description TEXT,
    created_by UUID,
    created_at,
    UNIQUE(tenant_id, key, version)
)

-- 8. Пресеты настроек
setting_presets (
    id UUID PK,
    vertical_code VARCHAR(50),
    key VARCHAR(100),
    value JSONB,
    name VARCHAR(255),
    description TEXT,
    times_used INT DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at
)

-- 9. Расхождения (лог)
deviations (
    id UUID PK,
    tenant_id UUID FK,
    issue_id UUID,
    intake_data JSONB,
    repair_data JSONB,
    deviation_type VARCHAR,
    severity VARCHAR,
    status VARCHAR DEFAULT 'pending',
    created_at
)
```

### 10.2 Индексы

```sql
-- Клиенты: поиск по идентификаторам
CREATE INDEX idx_clients_phone ON clients(tenant_id, phone);
CREATE INDEX idx_clients_telegram ON clients(tenant_id, telegram_id);

-- Диалоги: список для оператора
CREATE INDEX idx_dialogs_tenant_status ON dialogs(tenant_id, status, updated_at DESC);
CREATE INDEX idx_dialogs_client ON dialogs(client_id);

-- Сообщения: история
CREATE INDEX idx_messages_dialog ON messages(dialog_id, timestamp DESC);
CREATE INDEX idx_messages_client ON messages(client_id, timestamp DESC);

-- Сессии: авторизация
CREATE UNIQUE INDEX idx_sessions_token ON operator_sessions(session_token);

-- Настройки: актуальная версия
CREATE INDEX idx_settings_tenant_key ON tenant_settings(tenant_id, key, version DESC);
```

---

## 11. СХЕМА Neo4j

### 11.1 Основные узлы

| Узел | Назначение |
|------|------------|
| **ELO_Client** | Клиент |
| **ELO_Device** | Устройство |
| **ELO_Issue** | Случай обращения (контейнер) |
| **ELO_Intake** | Слова клиента (контейнер симптомов) |
| **ELO_Symptom** | Извлечённый симптом |
| **ELO_Diagnosis** | Диагноз мастера |
| **ELO_Repair** | Выполненный ремонт |
| **ELO_Message** | Сообщение (только меняющие граф) |
| **ELO_Fact** | Факт о клиенте |

### 11.2 Справочники

| Узел | Назначение |
|------|------------|
| **ELO_SymptomType** | Тип симптома |
| **ELO_DiagnosisType** | Тип диагноза |
| **ELO_RepairAction** | Тип ремонта |
| **ELO_ProblemCategory** | Категория проблемы (Дисплей, Батарея...) |

### 11.3 Диагностический движок

| Узел | Назначение |
|------|------------|
| **ELO_DefectSign** | Признак с вопросом |
| **ELO_SignCategory** | Категория признаков |
| **ELO_QuestionTree** | JSON дерево вопросов |
| **ELO_SignPattern** | Комбинация признаков → диагноз (позже) |

### 11.4 Связи

```
ELO_Message ──[:FROM]──────────────────► ELO_Client
           ──[:ABOUT_DEVICE]───────────► ELO_Device
           ──[:ABOUT_ISSUE]────────────► ELO_Issue

ELO_Client ──[:OWNS]───────────────────► ELO_Device
           ──[:BROUGHT]────────────────► ELO_Device (чужое)
           ──[:FAMILY {type}]──────────► ELO_Client
           ──[:REFERRED]───────────────► ELO_Client
           ──[:HAS_FACT]───────────────► ELO_Fact

ELO_Device ──[:HAS_ISSUE]──────────────► ELO_Issue

ELO_Issue  ──[:HAS_INTAKE]─────────────► ELO_Intake
           ──[:HAS_DIAGNOSIS]──────────► ELO_Diagnosis
           ──[:HAS_REPAIR]─────────────► ELO_Repair
           ──[:PROBLEM_CATEGORY]───────► ELO_ProblemCategory

ELO_Intake ──[:HAS_SYMPTOM]────────────► ELO_Symptom

ELO_Symptom ──[:SYMPTOM_TYPE]──────────► ELO_SymptomType

ELO_Diagnosis ──[:DIAGNOSIS_TYPE]──────► ELO_DiagnosisType

ELO_Repair ──[:REPAIR_ACTION]──────────► ELO_RepairAction

ELO_DefectSign ──[:INDICATES]──────────► ELO_DiagnosisType
ELO_SignPattern ──[:PREDICTS]──────────► ELO_DiagnosisType
```

---

## 12. НАСТРОЙКИ ТЕНАНТА

### 12.1 Структура

Гибрид key-value + версионирование:

```sql
tenant_settings (
    id UUID PK,
    tenant_id UUID FK,
    key VARCHAR(100),      -- иерархический ключ
    value JSONB,           -- любое значение
    version INT,           -- версия для отката
    previous_version_id UUID FK,
    ...
)
```

### 12.2 Примеры ключей

| Ключ | Значение | Описание |
|------|----------|----------|
| `auto_replies.greeting` | `"Привет! Чем помочь?"` | Приветствие |
| `auto_replies.outside_hours` | `"Работаем с 10 до 20"` | Вне рабочего времени |
| `auto_replies.reminder_2h` | `"Вы ещё думаете?"` | Напоминание |
| `auto_replies.incomplete_focus` | `"Вы не сказали про {device}"` | Дожим |
| `working_hours` | `{"start": "10:00", "end": "20:00"}` | График |
| `ai.freedom_level` | `50` | Уровень свободы AI |

### 12.3 Переменные в шаблонах

Простые подстановки: `{device}`, `{client_name}`, `{price}`

Без условий на MVP.

### 12.4 Пресеты

Вместо обмена настройками — готовые пресеты:

```sql
setting_presets (
    vertical_code,  -- 'phone_repair'
    key,            -- 'auto_replies.greeting'
    value,          -- "Привет! Чем помочь?"
    ...
)
```

При создании тенанта копируются пресеты вертикали.

---

## 13. ANDROID APP — НАВИГАЦИЯ

### 13.1 Было (Appeal-centric)

```
Appeals List → Appeal Detail → Messages
```

### 13.2 Стало (Client-centric)

```
Clients List → Client Detail → Devices → Issues
                    ↓
              Messages/Dialog
```

### 13.3 Структура экранов

| Экран | Что показывает | Источник |
|-------|----------------|----------|
| **Clients List** | Список клиентов с последним сообщением | PostgreSQL |
| **Client Detail** | Имя, телефон, каналы, устройства | PostgreSQL + Neo4j |
| **Device Detail** | Бренд, модель, активные issues | Neo4j |
| **Issue Detail** | Симптомы, диагнозы, ремонты | Neo4j + PostgreSQL |
| **Dialog/Chat** | Сообщения с клиентом | PostgreSQL |

### 13.4 QR-код клиента

**Содержит:** `client_id` (UUID)

**Что поднимаем:**
```
client_id
    ├──► PostgreSQL: clients, dialogs, messages
    └──► Neo4j: Client → Device → Issue → Symptom/Diagnosis/Repair
```

---

## 14. СЕРВЕРЫ И СЕРВИСЫ

### 14.1 RU Server (45.144.177.128)

| Сервис | Порт |
|--------|------|
| mcp-avito | 8765 |
| mcp-vk | 8767 |
| mcp-max | 8768 |
| mcp-form | 8770 |
| api-android | 8780 |
| Neo4j | 7474/7687 |
| Redis | 6379 |

### 14.2 Finnish Server (217.145.79.27)

| Сервис | Порт |
|--------|------|
| mcp-telegram | 8767 |
| mcp-whatsapp | 8766 |

### 14.3 n8n Server (185.221.214.83)

| Сервис | Порт |
|--------|------|
| n8n | 5678 |
| PostgreSQL | 6544 |
| Redis | 6379 |

---

## 15. СУЩЕСТВУЮЩИЕ API WORKFLOWS

Старые workflows можно использовать с минимальными изменениями:

| Endpoint | Метод | Назначение |
|----------|-------|------------|
| `/android/auth/login` | POST | Авторизация |
| `/api/operator/appeals/list` | GET | Список диалогов |
| `/api/android/appeals/:id` | GET | Детали диалога |
| + CRUD для devices, repairs | | |

**Паттерны:**
- Авторизация через `x-session-token` header
- Multi-tenant через `operator_devices.tenant_id`
- Счётчики статусов для UI

---

## 16. ПРИНЯТЫЕ РЕШЕНИЯ

### 16.1 Архитектурные

| Решение | Выбор |
|---------|-------|
| ELO_Message в Neo4j | Только сообщения, меняющие граф (вариант D) |
| Вертикали | Одна на MVP (phone_repair), эскалация на оператора |
| focus_score | Вычисляется из графа, не хранится |
| Intake vs Symptom | Intake = контейнер для Symptom'ов |
| QuestionTree | JSON в узле, не граф |
| Настройки | key-value + версионирование |
| Обмен настройками | Позже, сейчас — пресеты |

### 16.2 По базам данных

| Решение | Выбор |
|---------|-------|
| PostgreSQL | Удаляем старые elo_*, проектируем с нуля |
| Зеркалирование | Минимальное (только для API/поиска) |
| Deviations | Пишем в PostgreSQL, анализ — позже |

### 16.3 По MVP

| Компонент | MVP |
|-----------|-----|
| Сбор данных | ✅ |
| Инфраструктура БД | ✅ |
| Диагностический движок (сбор признаков) | ✅ |
| Deviation создание | ✅ Автоматически |
| Deviation анализ | ⏳ Позже |
| Обучение на расхождениях | ⏳ Позже |
| Обмен настройками | ⏳ Позже |

---

## 17. ГЛОССАРИЙ

| Термин | Определение |
|--------|-------------|
| **Вертикаль** | Бизнес-модель (phone_repair, buy_sell) |
| **Client** | Человек, единый профиль независимо от канала |
| **Dialog** | Единица общения с клиентом |
| **Device** | Устройство клиента |
| **Issue** | Случай обращения (контейнер) |
| **Intake** | Слова клиента (контейнер симптомов) |
| **Symptom** | Извлечённый симптом |
| **Diagnosis** | Что нашёл мастер |
| **Repair** | Что сделали |
| **Touchpoint** | Любое взаимодействие клиента с бизнесом |
| **Линия** | Путь Client → Device → Issue → Symptom |
| **Фокус** | Текущая точка внимания в диалоге |
| **focus_score** | Процент заполненности контекста (0-100%) |
| **Микроворонка** | Последовательность этапов диалога |
| **DefectSign** | Признак/дефект с вопросом для уточнения |
| **QuestionTree** | Дерево вопросов для адаптивного диалога |
| **SignPattern** | Комбинация признаков → диагноз |
| **Deviation** | Расхождение между Intake и Repair |
| **ai_freedom_level** | Уровень свободы AI (0-100) |
| **Prompt-in-Request** | Промпты в запросе, не хардкодятся |

---

## 18. СЛЕДУЮЩИЕ ШАГИ

После утверждения этого Summary:

1. **Разбиение на блоки** — определить независимые модули
2. **Интерфейсы между блоками** — как они общаются
3. **Порядок реализации** — что делать первым
4. **SQL миграции** — создать таблицы
5. **Neo4j constraints** — создать индексы и ограничения

---

**Документ:** ARCHITECTURE_SUMMARY_v2.md
**Дата:** 2025-12-10
**Автор:** Dmitry + Claude
**Статус:** Готов к разбиению на блоки
